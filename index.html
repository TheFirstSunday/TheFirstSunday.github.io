<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法"><meta name="keywords" content="FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法"><meta name="author" content="TheFirstSunday,undefined"><meta name="copyright" content="TheFirstSunday"><title>coder【前端-FE】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"V5C7R11NIT","apiKey":"37d9271c02b1e0f2f42bd334f8f0de94","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {"appId":"EDiQLCtfYJFYtECr3Adwmncl-gzGzoHsz","appKey":"MDXLAYtR8IlmgStY29ElIjge","placeholder":"Just Go Go."},
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">TheFirstSunday</div><div class="author-info-description">FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/TheFirstSunday" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:zhaonan266366@163.com" target="_blank">Email<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2621940203&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">7</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">2</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">前端-FE</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2020/12/30/hello-world/">开启我的个人博客</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><p>the personal blog with Hexo, theme Fan. Record every bit of learning and life.</p>
</div></div><a class="button-hover more" href="/2020/12/30/hello-world/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/30/message/">四种跨浏览器选项卡实时通信方法</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><p>多年来，随着对 Web 应用程序的需求增多，Web 浏览器的功能也不断增强。从而，可以找到实现类似功能的多种方法。本文将介绍一类很少被人关注的功能：在浏览器选项卡之间进行通信。以下是列举的几个适用场景：</p>
<ul>
<li>将对应用程序的主题修改（例如，深色或浅色主题）应用到所有已打开的浏览器选项卡中。</li>
<li>请求用于身份验证的最新令牌，并在浏览器选项卡之间共享。</li>
<li>跨浏览器选项卡同步应用程序状态。</li>
</ul>
<p>本文主要介绍几种跨浏览器通信的方法。然而，每种方法都有其优缺点。因此，本文会详细讨论它们，以便让您能够在实际开发中找到适用的最佳方法。</p>
<ol>
<li>使用本地存储事件 LocalStorage</li>
</ol>
<p>通过使用 LocalStorage，可以使得同一应用程序源中的选项卡之间进行通信。同时 LocalStorage 也支持事件，可以使用此功能跨浏览器选项卡进行通信，存储更新后，其他选项卡将接收事件。</p>
<p>例如，在一个选项卡中执行以下 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&quot;theme&quot;, &quot;dark&quot;);</span><br></pre></td></tr></table></figure>

<p>如下所示，监听事件的其他选项卡将接收它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (event.storageArea !&#x3D; localStorage) return;</span><br><span class="line">    if (event.key &#x3D;&#x3D;&#x3D; &#39;theme&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 测试使用 event.newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/bold-hoover-ol2jz?file=/index.html">codesandbox demo</a></p>
<ol start="2">
<li>使用 BroadcastChannel API 接口</li>
</ol>
<p>BroadcastChannel API 允许选项卡、窗口、Frames、Iframes 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a> 之间的通信。一个选项卡可以创建一个 Channel 并在其中发送消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new BroadcastChannel(&#39;app-data&#39;);</span><br><span class="line">channel.postMessage(&#39;post&#39;);</span><br></pre></td></tr></table></figure>

<p>其他选项卡可以监听频道，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new BroadcastChannel(&#39;app-data&#39;);</span><br><span class="line"></span><br><span class="line">channel.addEventListener (&#39;message&#39;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Disconnect the channel</span><br><span class="line">channel.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/white-hooks-9l081?file=/index.html">codesandbox demo</a></p>
<p>这样，浏览器上下文（<strong>Windows、Tabs、Frames、或 Iframes</strong>）之间可以进行通信。尽管这是浏览器选项卡之间的一种很便捷的通信方式，但 safari 和 IE 是不支持这种方式的。可以在 MDN 的 BroadcastChannel 文档中查看详细信息。</p>
<ol start="3">
<li>使用 Service Worker 发送消息</li>
</ol>
<p>可能会有疑问，Service Worker 是如何进入这种场景的。不过从根本上来说，Service Worker 支持发送消息，可以使用这些消息在浏览器选项卡之间进行通信。<br>使用 Service Worker，可以发送如下所示的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.controller.postMessage(&#123;</span><br><span class="line">    broadcast: data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时在接收 Worker 的其他浏览器选项卡中可以监听事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(&#39;message&#39;, async (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (&#39;boadcast&#39; in event.data ) &#123;</span><br><span class="line">        const allClients &#x3D; await clients.matchAll();</span><br><span class="line">        for (const client of allClients) &#123;</span><br><span class="line">            client.postMessage(event.broadcast);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方法提供更多的控制保障，是传递消息的可靠方法。但是，实现 Service Worker 需要一些关于 Service Worker API 的补充知识和额外工作。所以，在这种情况下，如果其他方法都不起作用，最好还是尝试这个方法。可以在 MDN 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration">Service Worker API</a> 文档中找到更多信息，还有一个完整的示例。</p>
<ol start="4">
<li>使用 Service Worker 发送消息</li>
</ol>
<p>Window.postMessage() 方法是跨浏览器选项卡、弹出窗口和 Iframes 进行通信的传统方法之一。可以按如下方式发送消息.<br><strong>Syntax</strong><br>targetWindow.postMessage(message, targetOrigin, [transfer]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const targetWindow &#x3D; window.opener;</span><br><span class="line">targetWindow.postMessage(message, targetOrigin)</span><br></pre></td></tr></table></figure>

<p>目标窗口可以监听事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (event.origin !&#x3D;&#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;) return;</span><br><span class="line">    &#x2F;&#x2F; 可以做测试</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>与其他方法相比，这种方法有一个优点：可以支持跨源通信。但它也有一个限制：需要引用另一个浏览器选项卡。所以这种方法只适用于通过 window.open() 或 document.open() 方法。可以在 MDN 文档中找到更多信息。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/gallant-mendeleev-jnbuo?file=/index.html">codesandbox demo</a></p>
</div></div><a class="button-hover more" href="/2020/12/30/message/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/06/fiber/">React Fiber</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="转载-前端工程师的自我修养：React-Fiber-是如何实现更新过程可控的"><a href="#转载-前端工程师的自我修养：React-Fiber-是如何实现更新过程可控的" class="headerlink" title="(转载) 前端工程师的自我修养：React Fiber 是如何实现更新过程可控的"></a>(转载) 前端工程师的自我修养：React Fiber 是如何实现更新过程可控的</h2><p>原文地址: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6911681589558640654?utm_source=gold_browser_extension">https://juejin.cn/post/6911681589558640654?utm_source=gold_browser_extension</a></p>
<p>前言<br>从 React 16 开始，React 采用了 Fiber 机制替代了原先基于原生执行栈递归遍历 VDOM 的方案，提高了页面渲染性能和用户体验。乍一听 Fiber 好像挺神秘，在原生执行栈都还没搞懂的情况下，又整出个 Fiber，还能不能愉快的写代码了。别慌，老铁！下面就来唠唠关于 Fiber 那点事儿。</p>
<h3 id="什么是-Fiber"><a href="#什么是-Fiber" class="headerlink" title="什么是 Fiber"></a>什么是 Fiber</h3><p>Fiber 的英文含义是“纤维”，它是比线程（Thread）更细的线，比线程（Thread）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（Cooperative）编程模型，帮助开发者用一种【既模块化又协作化】的方式来编排代码。</p>
<p>简单点说，Fiber 就是 React 16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前一竿子递归到底影响性能的做法。</p>
<h3 id="关于-Fiber-你需要知道的基础知识"><a href="#关于-Fiber-你需要知道的基础知识" class="headerlink" title="关于 Fiber 你需要知道的基础知识"></a>关于 Fiber 你需要知道的基础知识</h3><p>1.浏览器刷新率（帧）<br>页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16ms 左右。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。那么在这一帧的（16ms） 过程中浏览器又干了啥呢？<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2eea940e124be2973989154948d049~tplv-k3u1fbpfcp-zoom-1.image" alt="一帧图片"></p>
<p>通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程：</p>
<ul>
<li>接受输入事件</li>
<li>执行事件回调</li>
<li>开始一帧</li>
<li>执行 RAF (RequestAnimationFrame)</li>
<li>页面布局，样式计算</li>
<li>渲染</li>
<li>执行 RIC  (RequestIdelCallback)</li>
</ul>
<p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。这里提一下，如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。<br>2. JS 原生执行栈<br>React Fiber 出现之前，React 通过原生执行栈递归遍历 VDOM。当浏览器引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并将其压入执行栈，接下来每遇到一个函数调用，又会往栈中压入一个新的上下文。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    B();</span><br><span class="line">    C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>引擎在执行的时候，会形成如下这样的执行栈:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9177f8e0d59d4971bdc226fc46df3b65~tplv-k3u1fbpfcp-zoom-1.image" alt="执行栈图片"></p>
<p>浏览器引擎会从执行栈的顶端开始执行，执行完毕就弹出当前执行上下文，开始执行下一个函数，直到执行栈被清空才会停止。然后将执行权交还给浏览器。由于 React 将页面视图视作一个个函数执行的结果。每一个页面往往由多个视图组成，这就意味着多个函数的调用。<br>如果一个页面足够复杂，形成的函数调用栈就会很深。每一次更新，执行栈需要一次性执行完成，中途不能干其他的事儿，只能”一心一意”。结合前面提到的浏览器刷新率，JS 一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制。如果这个时间超过 16ms，当页面有动画效果需求时，动画因为浏览器不能及时绘制下一帧，这时动画就会出现卡顿。不仅如此，因为事件响应代码是在每一帧开始的时候执行，如果不能及时绘制下一帧，事件响应也会延迟。<br>3. 时间分片（Time Slicing）<br>时间分片指的是一种将多个粒度小的任务放入一个时间切片（一帧）中执行的一种方案，在 React Fiber 中就是将多个任务放在了一个时间片中去执行。<br>4. 链表<br>在 React Fiber 中用链表遍历的方式替代了 React 16 之前的栈递归方案。在 React 16 中使用了大量的链表。例如：</p>
<p>使用多向链表的形式替代了原来的树结构</p>
<p>例如下面这个组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    A1</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B1&quot;</span>&gt;</span></span><br><span class="line">        B1</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;C1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span><br><span class="line">        B2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>会使用下面这样的链表表示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/094d4f8810d4473fbd1ebcea594073dd~tplv-k3u1fbpfcp-zoom-1.image" alt="链表"></p>
</li>
<li><p>副作用单链表</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1180ed8b2b104309bcb907e6a647de01~tplv-k3u1fbpfcp-zoom-1.image" alt="副租用单链表"></p>
<ul>
<li>状态更新单链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d543c88f1b9f45a48f6181ce76959690~tplv-k3u1fbpfcp-zoom-1.image" alt="状态更新单链表"><br>…</p>
<p>链表是一种简单高效的数据结构，它在当前节点中保存着指向下一个节点的指针，就好像火车一样一节连着一节</p>
<p>-遍历的时候，通过操作指针找到下一个元素。但是操作指针时（调整顺序和指向）一定要小心。<br>链表相比顺序结构数据格式的好处就是：</p>
<ul>
<li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。</li>
<li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。</li>
</ul>
<p>但链表也不是完美的，缺点就是：</p>
<ul>
<li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。</li>
<li>不能自由读取，必须找到他的上一个节点。</li>
</ul>
<p>React 用空间换时间，更高效的操作可以方便根据优先级进行操作。同时可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用。</p>
<h3 id="React-Fiber-是如何实现更新过程可控？"><a href="#React-Fiber-是如何实现更新过程可控？" class="headerlink" title="React Fiber 是如何实现更新过程可控？"></a>React Fiber 是如何实现更新过程可控？</h3><p>前面讲完基本知识，现在正式开始介绍今天的主角 Fiber，看看 React Fiber 是如何实现对更新过程的管控。</p>
<p>更新过程的可控主要体现在下面几个方面:</p>
<ul>
<li>任务拆分</li>
<li>任务挂起、恢复、终止</li>
<li>任务具备优先级</li>
</ul>
<ol>
<li>任务拆分<br>前面提到，React Fiber 之前是基于原生执行栈，每一次更新操作会一直占用主线程，直到更新完成。这可能会导致事件响应延迟，动画卡顿等现象。<br>在 React Fiber 机制中，它采用”化整为零”的战术，将调和阶段（Reconciler）递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责一个节点的处理。例如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">    &lt;div id=<span class="string">&quot;A1&quot;</span>&gt;</span><br><span class="line">            A1</span><br><span class="line">        &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">            B1</span><br><span class="line">            &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;C1&lt;/div&gt;</span><br><span class="line">            &lt;div id=<span class="string">&quot;C2&quot;</span>&gt;C2&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;B2&quot;</span>&gt;B2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">ReactDom.render(jsx,<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>这个组件在渲染的时候会被分成八个小任务，每个任务用来分别处理 A1(div)、A1(text)、B1(div)、B1(text)、C1(div)、C1(text)、C2(div)、C2(text)、B2(div)、B2(text)。再通过时间分片，在一个时间片中执行一个或者多个任务。这里提一下，所有的小任务并不是一次性被切分完成，而是处理当前任务的时候生成下一个任务，如果没有下一个任务生成了，就代表本次渲染的 Diff 操作完成。</p>
<h3 id="挂起、恢复、终止"><a href="#挂起、恢复、终止" class="headerlink" title="挂起、恢复、终止"></a>挂起、恢复、终止</h3><p>再说挂起、恢复、终止之前，不得不提两棵 Fiber 树，workInProgress tree 和 currentFiber tree。<br>workInProgress 代表当前正在执行更新的 Fiber 树。在 render 或者 setState 后，会构建一颗 Fiber 树，也就是 workInProgress tree，这棵树在构建每一个节点的时候会收集当前节点的副作用，整棵树构建完成后，会形成一条完整的副作用链。<br>currentFiber 表示上次渲染构建的 Fiber 树。在每一次更新完成后 workInProgress 会赋值给  currentFiber。在新一轮更新时 workInProgress tree 再重新构建，新 workInProgress 的节点通过 alternate 属性和 currentFiber 的节点建立联系。<br>在新 workInProgress tree 的创建过程中，会同 currentFiber 的对应节点进行 Diff 比较，收集副作用。同时也会复用和 currentFiber 对应的节点对象，减少新创建对象带来的开销。也就是说无论是创建还是更新，挂起、恢复以及终止操作都是发生在 workInProgress tree 创建过程中。workInProgress tree  构建过程其实就是循环的执行任务和创建下一个任务，大致过程如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6051a82ff5604046a11a80c6fe0d4d00~tplv-k3u1fbpfcp-zoom-1.image" alt="process"></p>
<p>当没有下一个任务需要执行的时候，workInProgress tree 构建完成，开始进入提交阶段，完成真实 DOM 更新。<br>在构建 workInProgressFiber tree 过程中可以通过挂起、恢复和终止任务，实现对更新过程的管控。下面简化了一下源码，大致实现如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitWork = <span class="literal">null</span>;<span class="comment">//下一个执行单元</span></span><br><span class="line"><span class="comment">//开始调度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">    nextUnitWork = task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环执行工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;<span class="comment">//是否要让出时间片交出控制权</span></span><br><span class="line">    <span class="keyword">while</span>(nextUnitWork &amp;&amp; !shouldYield)&#123;</span><br><span class="line">        nextUnitWork = performUnitWork(nextUnitWork)</span><br><span class="line">        shouldYield = deadline.timeRemaining()&lt;<span class="number">1</span> <span class="comment">// 没有时间了，检出控制权给浏览器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitWork) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;所有任务完成&quot;</span>)</span><br><span class="line">        <span class="comment">//commitRoot() //提交更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有任务，但是交出控制权后,请求下次调度</span></span><br><span class="line">    requestIdleCallback(workLoop,&#123;<span class="attr">timeout</span>:<span class="number">5000</span>&#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 处理一个小任务，其实就是一个 Fiber 节点，如果还有任务就返回下一个需要处理的任务，没有就代表整个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitWork</span>(<span class="params">currentFiber</span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> FiberNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>挂起</li>
</ul>
<p>当第一个小任务完成后，先判断这一帧是否还有空闲时间，没有就挂起下一个任务的执行，记住当前挂起的节点，让出控制权给浏览器执行更高优先级的任务。</p>
<ul>
<li>恢复<br>在浏览器渲染完一帧后，判断当前帧是否有剩余时间，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。这样完美的解决了调和过程一直占用主线程的问题。<br>那么问题来了他是如何判断一帧是否有空闲时间的呢？答案就是我们前面提到的 RIC (RequestIdleCallback) 浏览器原生 API，React 源码中为了兼容低版本的浏览器，对该方法进行了 Polyfill。<br>当恢复执行的时候又是如何知道下一个任务是什么呢？答案在前面提到的链表。在 React Fiber 中每个任务其实就是在处理一个 FiberNode 对象，然后又生成下一个任务需要处理的 FiberNode。顺便提一嘴，这里提到的FiberNode 是一种数据格式，下面是它没有开美颜的样子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(tag, pendingProps, key, mode) &#123;</span><br><span class="line">        <span class="comment">// 实例属性</span></span><br><span class="line">        <span class="built_in">this</span>.tag = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">        <span class="built_in">this</span>.key = key; <span class="comment">// react 元素上的 key 就是 jsx 上写的那个 key ，也就是最终 ReactElement 上的</span></span><br><span class="line">        <span class="built_in">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// createElement的第一个参数，ReactElement 上的 type</span></span><br><span class="line">        <span class="built_in">this</span>.type = <span class="literal">null</span>; <span class="comment">// 表示fiber的真实类型 ，elementType 基本一样，在使用了懒加载之类的功能时可能会不一样</span></span><br><span class="line">        <span class="built_in">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象</span></span><br><span class="line">        <span class="comment">// fiber</span></span><br><span class="line">        <span class="built_in">this</span>.return = <span class="literal">null</span>; <span class="comment">// 父节点，指向上一个 fiber</span></span><br><span class="line">        <span class="built_in">this</span>.child = <span class="literal">null</span>; <span class="comment">// 子节点，指向自身下面的第一个 fiber</span></span><br><span class="line">        <span class="built_in">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 兄弟组件, 指向一个兄弟节点</span></span><br><span class="line">        <span class="built_in">this</span>.index = <span class="number">0</span>; <span class="comment">//  一般如果没有兄弟节点的话是0 当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff</span></span><br><span class="line">        <span class="built_in">this</span>.ref = <span class="literal">null</span>; <span class="comment">// reactElement 上的 ref 属性</span></span><br><span class="line">        <span class="built_in">this</span>.pendingProps = pendingProps; <span class="comment">// 新的 props</span></span><br><span class="line">        <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">// 旧的 props</span></span><br><span class="line">        <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">// fiber 上的更新队列执行一次 setState 就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新</span></span><br><span class="line">        <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>; <span class="comment">// 对应  memoizedProps，上次渲染的 state，相当于当前的 state，理解成 prev 和 next 的关系</span></span><br><span class="line">        <span class="built_in">this</span>.mode = mode; <span class="comment">// 表示当前组件下的子组件的渲染方式</span></span><br><span class="line">        <span class="comment">// effects</span></span><br><span class="line">        <span class="built_in">this</span>.effectTag = NoEffect; <span class="comment">// 表示当前 fiber 要进行何种更新</span></span><br><span class="line">        <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>; <span class="comment">// 指向下个需要更新的fiber</span></span><br><span class="line">        <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>; <span class="comment">// 指向所有子节点里，需要更新的 fiber 里的第一个</span></span><br><span class="line">        <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>; <span class="comment">// 指向所有子节点中需要更新的 fiber 的最后一个</span></span><br><span class="line">        <span class="built_in">this</span>.expirationTime = NoWork; <span class="comment">// 过期时间，代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">        <span class="built_in">this</span>.childExpirationTime = NoWork; <span class="comment">// child 过期时间</span></span><br><span class="line">        <span class="built_in">this</span>.alternate = <span class="literal">null</span>; <span class="comment">// current 树和 WorkInProgress 树之间的相互引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额…看着好像有点上头，这是开了美颜的样子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae2b97cdc0b745c296a6e81b4fe8ba88~tplv-k3u1fbpfcp-zoom-1.image" alt="FiberNode"></p>
<p>是不是好看多了？在每次循环的时候，找到下一个执行需要处理的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitWork</span>(<span class="params">currentFiber</span>)</span>&#123;</span><br><span class="line"><span class="comment">//beginWork(currentFiber) //找到儿子，并通过链表的方式挂到currentFiber上，每一偶儿子就找后面那个兄弟</span></span><br><span class="line">    <span class="comment">//有儿子就返回儿子</span></span><br><span class="line">    <span class="keyword">if</span>(currentFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.child;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有儿子，则找弟弟</span></span><br><span class="line">    <span class="keyword">while</span>(currentFiber)&#123;<span class="comment">//一直往上找</span></span><br><span class="line">        <span class="comment">//completeUnitWork(currentFiber);//将自己的副作用挂到父节点去</span></span><br><span class="line">        <span class="keyword">if</span>(currentFiber.sibling)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.sibling</span><br><span class="line">        &#125;</span><br><span class="line">        currentFiber = currentFiber.return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次任务结束后返回该处理节点的子节点或兄弟节点或父节点。只要有节点返回，说明还有下一个任务，下一个任务的处理对象就是返回的节点。通过一个全局变量记住当前任务节点，当浏览器再次空闲的时候，通过这个全局变量，找到它的下一个任务需要处理的节点恢复执行。就这样一直循环下去，直到没有需要处理的节点返回，代表所有任务执行完成。最后大家手拉手，就形成了一颗 Fiber 树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12f5f56f28c34ae7b25de07e36996830~tplv-k3u1fbpfcp-zoom-1.image" alt="Fiber Tree"></p>
<ul>
<li>终止<br>其实并不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断是否有优先级更高的执行任务，如果有就终止原来将要执行的任务，开始新的 workInProgressFiber 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是在 React 16 以后生命周期函数 componentWillMount 有可能会执行多次的原因。</li>
</ul>
<ol>
<li>任务具备优先级<br>React Fiber 除了通过挂起，恢复和终止来控制更新外，还给每个任务分配了优先级。具体点就是在创建或者更新 FiberNode 的时候，通过算法给每个任务分配一个到期时间（expirationTime）。在每个任务执行的时候除了判断剩余时间，如果当前处理节点已经过期，那么无论现在是否有空闲时间都必须执行改任务。</li>
</ol>
<p>同时过期时间的大小还代表着任务的优先级。<br>任务在执行过程中顺便收集了每个 FiberNode 的副作用，将有副作用的节点通过 firstEffect、lastEffect、nextEffect 形成一条副作用单链表 AI(TEXT)-B1(TEXT)-C1(TEXT)-C1-C2(TEXT)-C2-B1-B2(TEXT)-B2-A。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ae8e1febebe49be932fc071181ca9ed~tplv-k3u1fbpfcp-zoom-1.image" alt="副作用单链表"></p>
<p>其实最终都是为了收集到这条副作用链表，有了它，在接下来的渲染阶段就通过遍历副作用链完成 DOM 更新。这里需要注意，更新真实 DOM 的这个动作是一气呵成的，不能中断，不然会造成视觉上的不连贯。<br>关于 React Fiber 的思考</p>
<ol>
<li>能否使用生成器（generator）替代链表<br>在 Fiber 机制中，最重要的一点就是需要实现挂起和恢复，从实现角度来说 generator 也可以实现。那么为什么官方没有使用 generator 呢？猜测应该是是性能方面的原因。生成器不仅让您在堆栈的中间让步，还必须把每个函数包装在一个生成器中。一方面增加了许多语法方面的开销，另外还增加了任何现有实现的运行时开销。性能上远没有链表的方式好，而且链表不需要考虑浏览器兼容性。</li>
<li>Vue 是否会采用 Fiber 机制来优化复杂页面的更新<br>这个问题其实有点搞事情，如果 Vue 真这么做了是不是就是变相承认 Vue 是在”集成” Angular 和 React 的优点呢？React 有 Fiber，Vue 就一定要有？<br>两者虽然都依赖 DOM Diff，但是实现上且有区别，DOM Diff 的目的都是收集副作用。Vue 通过 Watcher 实现了依赖收集，本身就是一种很好的优化。所以 Vue 没有采用 Fiber 机制，也无伤大雅。<br>总结<br>React Fiber 的出现相当于是在更新过程中引进了一个中场指挥官，负责掌控更新过程，足球世界里管这叫前腰。抛开带来的性能和效率提升外，这种“化整为零”和任务编排的思想，可以应用到我们平时的架构设计中。</li>
</ol>
<p>作者：政采云前端团队<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6911681589558640654">https://juejin.cn/post/6911681589558640654</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div></div><a class="button-hover more" href="/2020/12/06/fiber/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/11/28/complexity/">时间与空间复杂度</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="算法时间与空间复杂度"><a href="#算法时间与空间复杂度" class="headerlink" title="算法时间与空间复杂度"></a>算法时间与空间复杂度</h2><p>算法、数据结构在我们的日常工作中还是很常见的，只要你细心观察，就会发现算可以体现在我们工作中的各个层面.<br>例如:</p>
<ul>
<li>浏览器的历史中的前进后退是不是可以把它看做一个线性的栈结构，history的pop、push对应这个栈的出栈、压栈.</li>
<li>const obj = {}; let obj2 = {}; let a = 1; const a = 1; 用数据结构的思维也可以更好的理解ES6的特性。</li>
</ul>
<p>随着计算机行业发展，不管是前端亦或是后端，算法都是进阶的一个绊脚石，可以说不会算法永远也成不了一个合格<br>的高级工程师，想要进大厂确实要会些算法，但是它并不只是为了面试，它和我们的程序是息息相关的.</p>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>数据结构其实就是是程序存储组织数据的方式，一个数据结构是由程序中的数据元素按照某种逻辑关系组织起来的，是若干个数据元素的组合.</p>
<p>数据结构是程序中处理数据的基本单位，在程序中作为一个整体来使用</p>
<p>例如一个数字 1 或者一个字符 A，它是一种数据结构</p>
<p>例如一个数组 [‘dog’, ‘cat’, ‘wolves’]，它是由字符串组合而成的数组，也是一种数据结构</p>
<p>通俗来说，用一定格式组成的数据都是数据结构，我们比较常见的数据结构有字符串、数组、对象、堆、栈、链表、树、哈希表等等，你可能对着其中的一些数据结构并不了解，不要担心，你并不需要立刻知道它们都是什么，对于前端来说，我们使用 JavaScript 这个令我们又爱又恨的语言，它本身就存在的数据结构很少，那么对于像链表、树等等这些结构都是通过对象来模拟的，这点要先知道.</p>
<p>在许多程序设计当中，数据结构的选择是一个基本的设计考虑因素，系统实现的困难程度和系统构造的质量都严重依赖于是否选择了最优的数据结构，选择最优的数据结构能够有效的提高运行的效率和节约存储空间的使用，但是要知道，没有十全十美的数据结构，每种数据结构都有局限性同样也有优点，要根据需求来选择合适的数据结构.</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>什么是算法，我们都知道 1+2+3=6，为什么等于 6 呢，你可能会说，1 加 2等于 3，两个 3 相加等于 6，这是小学生都会的数学常识，它就是广义上的算法</p>
<p>算法其实就是解决一个问题的完整步骤描述，是指完成一个任务准确而完整的步骤描述</p>
<p>算法的设计很多时候需要取决于数据结构，而算法的实现更依赖于采用的数据结构</p>
<p>提出一个问题的算法是一个从抽象到具体的过程</p>
<p>分析问题，选择数据结构，得出初步的解决方法</p>
<p>将解决方法合理地拆分，整理成许多步骤</p>
<p>为重复的步骤选择合理的循环变量</p>
<p>使用易转化为程序实现的自然语言简练地描述算法</p>
<p>了解了什么是算法之后，我们来看时间和空间复杂度，衡量不同算法之间的优劣我们通常从两个维度来考究</p>
<ul>
<li>时间维度：指执行代码所消耗的时间，即时间复杂度</li>
<li>空间维度：指执行代码所消耗的空间，即空间复杂度</li>
</ul>
<p>接下来就开始逐步剖析时间和空间复杂度了，先说时间复杂度</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在说时间复杂度之前，我们首先要理解一个概念即代码执行次数，也可称之为语句频度或时间频度，用 T(n) 表示</p>
<p>我们用例子来一步一步阐述，首先我们来看函数 fn1</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>我们来看这个函数中的语句会执行多少次</p>
<p>很明显此函数内部只有两个语句，即 console.log(“run”) 和 console.log(“end”)，那么我们说这个函数体内代码执行次数是 2</p>
<p>我们再来看函数 fn2</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>我们先来看函数 fn2 中有几条可执行语句</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">i &lt; n</span><br><span class="line">i++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br></pre></td></tr></table></figure></code></pre>
<p>我们假设 n = 3，然后依次带入进去，看看各个执行语句执行了多少次<br>let i = 0 此条声明语句只在第一次 for 循环声明时执行 1 次<br>i &lt; n 此条语句执行次数根据形参 n 的大小变化，n = 3 时，即 i=0,i=1,i=2,i=3 时会执行，即此条语句执行次数为 n + 1 次<br>i++ 此条语句执行次数也是根据形参 n 的大小变化，n = 3 时，即 i=0,i=1,i=2 时会执行，即 n 次<br>console.log(“run”) 此条语句执行次数还是根据形参 n 的大小变化，n = 3 会执行 3 次，那么此语句在函数内部即会执行 n 次</p>
<p>1 + (n + 1) + n + n = (3n + 2)</p>
<p>那么函数 fn2 内共执行 3n + 2 次</p>
<p>一段代码的总执行次数我们通常会用 T(n) 来表示，那么调用一次上面 fn1/fn2 两函数的总执行次数即</p>
<p>T(n) = 2 // fn1<br>T(n) = 3n + 2 // fn2</p>
<p>上面的 n，指的是为问题的规模，即输入数据的大小或者说数量，你也可以简单的理解为 T 就是函数本身，n 就是参数，也就是说</p>
<p>函数 fn1 任何情况下执行次数都为 2</p>
<p>函数 fn2 的总执行次数会根据 n 的大小变化而产生一个变化</p>
<p>我们思考一下，我们可以使用一段代码的执行总次数来衡量执行速度吗？</p>
<p>答案当然是不行的，当代码行数比较多的时候，我们一条一条的数来计算执行总次数太麻烦了，例如函数中套用函数时、循环中套用循环时，想要精确计算执行次数都是非常麻烦的</p>
<p>所以，在算法中，我们一般用 T(n) 简化后的估算值来表达代码执行的速度，通常我们用大些字母 O 来表示，即大 O 表示法，由于是估算，它表示的是代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度</p>
<p>明确了这个概念以后，我们就可以来算时间复杂度了，还是用上面 fn1/fn2 两函数例</p>
<p>// fn1<br>T(n) = 2</p>
<p>// fn2<br>T(n) = 3n + 2</p>
<p>首先我们来看函数 fn1，它的执行总次数为 2，一个 常数(常数级)，也就是说此函数无论何时它的总执行次数都是 2，是一个不变的值，那么我们使用时间复杂度 O 来表示时直接估算为 1 就可以，即时间复杂度为 O(1)</p>
<p>我们再来看函数 fn2 ，它的执行次数 T(n) 是 3n + 2 即 常数<em>n + 常数，这里我们完全可以看成 常数</em>n 和 +常数 两部分，随着 n 的增大，只有前一个部分会有变化，后面是不变的，所以在表示时间复杂度时就可以忽略后面不变的常数，即 常数<em>n，而 常数</em>n 中过的常数我们也可以直接当做 1，或者说忽略掉这个作为系数的常数，那么最终可以得出函数 fn2 的时间复杂度为 n，即 O(n)</p>
<p>PS：晓得可能有人把数学知识还给老师了，所以解释下</p>
<p>常数： 常数就是指平常的数值，可简单的理解为固定不变的数值</p>
<p>系数： 系数指代数式的单项式中的数字因数，例如 a = 1<em>a则它的系数为1,2b=2</em>b ，则它的系数为 2</p>
<p>我们再来举个例子，如下面这个多项式代指一个函数的 T(n)，求它的时间复杂度</p>
<p>T(n) = 10n^4 + 100n^2 + 1000</p>
<p>其实，对于多项式，我们只需要保留最高次项就行了，也就说，保留 n 的最高次方数就可以了，这个例子中保留的也就是 n 的 4 次方，系数和常数皆可以忽略，最终得到的时间复杂度即为 O(n^4)</p>
<p>结论：</p>
<p>T(n) 为常数时，时间复杂度为 O(1) ，反之时间复杂度为 O(保留T(n)的最高次项并去掉最高次项的系数)</p>
<p>接下来，我们看几个例子来判断下几段代码的时间复杂度</p>
<p>例1：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn01</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你看这是啥&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是一个输出&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>上面这个函数 fn01 中只有一条条的语句，共执行 5 次，毫无变化，时间复杂度即 O(1) ，此为常数级时间复杂度</p>
<p>例2：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn02</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;这是一个输出🎓&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>如上，函数 fn02 同上文中的例子 fn2，一个循环，时间复杂度即为 O(n) ，此为线性级时间复杂度</p>
<p>例3：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn03</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>这个题和上面就不太一样了，我们先单独看内部的循环，内部循环大概会执行 n 次，再来看外部循环又会执行 n 次，最终也就是 n * n = n^2，即函数 fn03 的时间复杂度为 O(n^2) ，此为平方级时间复杂度，如果是三层循环也就是时间复杂度为 O(n^3) 时，即立方级时间复杂度</p>
<p>从这里我们就可以看出来，一段代码有多少层循环，时间复杂度就是 n 的多少次方，所以尽量避免多层循环嵌套</p>
<p>例4：</p>
<p>我们再来看下面这个函数 fn04</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn04</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>此函数中有一个双循环，有一个单循环，即执行次数大概是 n^2 + n，根据我们上面说的保留最高次项，那么函数 fn04 的时间复杂度即为 O(n^2)</p>
<p>例5：</p>
<p>算法中肯定不只是上面那种寻常的循环，再来看下面这一个</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn05</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>其实遇到这种，我们直接带入进去试一试即可知其规律</p>
<p>当 i = 0 时，里层循环会执行 n 次</p>
<p>当 i = 1 时，里层循环会执行 n - 1 次</p>
<p>当 i = 2 时，里层循环会执行 n - 2 次</p>
<p>当 i = 3 时，里层循环会执行 n - 3 次</p>
<p>这个时候我们就发现了规律，每当 i 增加 1，里层循环就少执行 1 次，那么就简单了</p>
<p>当 i = n - 2 时，里层循环会执行 2 次</p>
<p>当 i = n - 1 时，里层循环会执行 1 次</p>
<p>最终我们把 n 个里层循环的执行次数相加即可得出最终的一个不精确的总执行次数</p>
<p>T(n) = n + (n - 1) + (n - 2) + … + 3 + 2 + 1</p>
<p>如上，这是一个等差数列，嗯，晓得，会补充</p>
<p>如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，这个数列就叫做等差数列，而这个常数叫做等差数列的公差，公差常用字母 d 表示</p>
<p>例如：1,3,5,7,9……（2n-1) ，等差数列 S(n) 的通项公式为：S(n) = S1 + (n-1) * d，前 n 项和公式如下</p>
<p>S(n) = n<em>S1 + n</em>(n - 1)*d/2</p>
<p>// 或</p>
<p>S(n) = n*(S1 + Sn)/2</p>
<p>如此我们计算结果就成，我们上面的数列中，公差 d 为 -1，带入公式即可，第二个公式简单，用第二个好了，计算结果都是一样的</p>
<p>// n*(S1 + Sn)/2</p>
<p>n*(n + 1)/2 = (n^2 + n)/2 = (1/2)n^2 + (1/2)n</p>
<p>最终我们得到了 (1/2)n^2 + (1/2)n ，按照上文中取最高次项去掉系数，即时间复杂度为 O(n^2)</p>
<p>例6：</p>
<p>再来看一个例子</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn06</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>还是老样子，如果你不晓得怎么看，可以先带入几个参数试一下，看一看规律</p>
<p>我们可以分别使用 n=2, n=4, n=8, n=16，观察其循环中打印次数，当然你也可以直接运行一下代码，过程不过多阐述了，我们直接看结果</p>
<p>n=2 时打印1次 T(n)=1<br>n=4 时打印2次 T(n)=2<br>n=8 时打印3次 T(n)=3<br>n=16 时打印4次 T(n)=4</p>
<p>对于执行次数产生主要影像的就是循环语句中的 i*=2，每次循环 i 都会变成自身的两倍，仔细观察我们就可以得出这样一个规律性结果</p>
<p>n=2 时打印1次 T(n)=1 // 2^1 = 2<br>n=4 时打印2次 T(n)=2 // 2^2 = 4<br>n=8 时打印3次 T(n)=3 // 2^3 = 8<br>n=16 时打印4次 T(n)=4 // 2^4 = 16</p>
<p>根据上面的规律我们不难发现，那么2^执行次数=n，即 2^T(n)=n ，我们求 T(n)，调个就行了，也就是以 2 为底 n 的对数，即 T(n)=log_2 n</p>
<p>PS：又来补数学了</p>
<p>对数： 假如 a^n=b，即 a 的 n 次方等于 b，我们求 n 的值，那么这里为了方便表示就可以写成 log_a b，即以 a 为底 b 的对数，a 是底数，b 是真数，而 n 就是对数</p>
<p>你可能会在纠结为什么只观察循环中的打印次数而不计算其所有的执行次数，原因上面也说过了，这些固有的常数及系数完全可以忽略，好吧，我们再最后推一遍</p>
<p>中间输出为 log_2 n 次，let i = 1 只会执行一次，i&lt;n 会执行 log_2 n + 1 次，i*=2 也会执行 log_2 n 次，加起来就是 log_2 n + log_2 n + 1 + log_2 n，即 3log_2 n + 2，除去系数 3 和常数 2，我们得出了 log_2 n ，在时间复杂度的计算中 log 的底数也是可以省略的，所以最终函数 fn06 的时间复杂度为 O(log n) ，也就是对数级时间复杂度</p>
<p>例7：</p>
<p>最后在给大家来一个例子吧</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn07</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; m)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;你看懂了吗&quot;</span>)</span><br><span class="line">        j = j * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>如上图，此函数有两个参数，对应了里外两个循环，我们先从内部循环看起，眼熟吗？其实内部循环和上题函数 fn06 中的循环是一样的，只是一个用的 for ，一个用的 while，上题中的时间复杂度我们就不再叙述了，那么内层循环时间复杂度为 O(log n)</p>
<p>我们再来看外层循环，也是上面解释过的，单看外层循环时间复杂度是 O(n)</p>
<p>两个循环是嵌套关系，相乘就可以了，所以函数 fn07 的时间复杂度即为 O(n*log n) ，也就是线性对数级时间复杂度</p>
<p>正如此函数输出，你看懂了吗？</p>
<p>常见的时间复杂度量级有</p>
<p>常数级 O(1)<br>对数级 O(log n)<br>线性级 O(n)<br>线性对数级 O(n*log n)<br>平方级 O(n^2)<br>立方级 O(n^3)<br>K次方级 O(n^k)<br>指数级 O(2^n)<br>上面从上到下依次时间复杂度越来越大，执行效率越来越低，大部分常用的在上面的图表中都有展示</p>
<p>所以在程序或是刷题中，我们应该尽量使用低时间复杂度的方法</p>
<p>时间复杂度就到此为止了，我们也列举了常见的时间复杂度，接下来我们来看看空间复杂度</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度其实就是对一个算法或者说一段代码在运行过程中占用存储空间大小表达方式</p>
<p>我们上面讲过了时间复杂度，那么再来说空间复杂度会简单的很多</p>
<p>空间复杂度也就是 S(n) ，它同样会用大O表示法来表示，我们直接上例子</p>
<p>例1：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn001</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;空间复杂度&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>首先，我们知道，空间复杂度和存储空间有关，而存储空间是由什么决定的，肯定是声明的变量啊，我们直接来找函数 fn001 中的变量声明，只有一个 i ，也就是说此函数只有开辟了一块空间供 i 使用，那么空间复杂度 S(n) 即为 O(1) ，你可能会说 i 不是一直在变吗，是的它是在变，但是不管怎么变，它还是一个数字，占用空间大小都一致</p>
<p>空间复杂度和时间复杂度一样，当代码里声明的变量是一个常量，不会根据传入值的变化而变化，那么也它的空间复杂度是 O(1)</p>
<p>例2：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn002</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        arr.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>这个例子中我们声明了一个数组，我们知道数组中是可以存各种类型的，在循环中，我们根据 n 的大小向数组 arr 中 push 元素，所以，n 多大，数组就有多少元素，就占用了多少空间，所以空间复杂度S(n) = O(n)</p>
<h3 id="空间复杂度小结"><a href="#空间复杂度小结" class="headerlink" title="空间复杂度小结"></a>空间复杂度小结</h3><p>空间复杂度里，只列出了两个例子，是因为一般情况下，我们用不到其他的，空间复杂度一般只会是 O(1)/O(n)/O(n^2)，其它的很少见，当然也有，我们在知道了时间复杂度再分析空间复杂度也很好分析，就不过多赘述了</p>
<p>关于分析空间复杂度，其实我们直接从声明的变量入手就可以，看函数体内声明的变量根据传入值的变化而变化来分析</p>
<p>另外，这里我们没有列举递归情况，请注意，递归就是函数套函数，像俄罗斯套娃一样的，这中间其实有一个问题，我们知道，递归函数，每层递归里都会开辟一个递归栈，每次递归产生的变量等空间消耗都会存在递归栈中，这也是一个空间，不管你有没有声明变量，只要递归了递归栈它都存在，也就是说只要存在递归的情况，基本上最少的空间复杂度也是 O(n) 了，所以我们尽可能的在能使用迭代的情况下就不使用递归</p>
<h3 id="时间-VS-空间"><a href="#时间-VS-空间" class="headerlink" title="时间 VS 空间"></a>时间 VS 空间</h3><p>开头我们说了，评价一个算法的效率我们主要是从它的时间和空间两个维度看，但是，通常我们在算法中，时间和空间就是鱼和熊掌的关系，这时候可能一道算法题有两种解法，一种时间复杂度低，但空间复杂度稍高，另一种则反之</p>
<p>这个时候怎么办呢？细品就知道了，在开发中，我们一般都是时间优于空间的，你想啊，一个程序，用户不会关心的占用了多少内存，但是他会关心你这个程序他在使用时的执行速度，况且，空间也就是磁盘，现阶段磁盘我们可以花钱扩容，时间上就没这么简单了，所以某些相对的情况下，空间换时间是可以令人接受的</p>
<p>虽说空间换时间可行，但也不能一味的空间换时间，我们还是要尽可能降低两个维度的复杂度，少数对立情况下，可空间换时间</p>
<p>我们在刷算法的时候，不是刷完了就完事了，我们还要去分析我们的题解对应的时间及空间复杂度，可以分析多种题解之间的复杂度，对比找出最优解</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></p>
</div></div><a class="button-hover more" href="/2020/11/28/complexity/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/10/07/git-emoji/">git-emoji</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;feat: :sparkles: built a Tank, yesterday.&quot;</span><br><span class="line"></span><br><span class="line">git commit -m &quot;feat: :sparkles: built a Rocket, today.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Git提交添加emoji图标"><a href="#Git提交添加emoji图标" class="headerlink" title="Git提交添加emoji图标"></a>Git提交添加emoji图标</h2><p><a target="_blank" rel="noopener" href="https://gitmoji.carloscuesta.me/">https://gitmoji.carloscuesta.me/</a></p>
<img src="/2020/10/07/git-emoji/git_emoji.png" class="" title="This is an image">

<p>在提交内容的前面增加了emoji标签：  **:emoji:**，其中emoji是表情图标的标签，列表见下面的附录表格。</p>
<table>
<thead>
<tr>
<th>emoji</th>
<th>emoji代码</th>
<th>commit 说明</th>
</tr>
</thead>
<tbody><tr>
<td>:art: (调色板)</td>
<td><code>:art:</code></td>
<td>改进代码结构/代码格式</td>
</tr>
<tr>
<td>:zap: (闪电):racehorse: (赛马)</td>
<td><code>:zap:“:racehorse:</code></td>
<td>提升性能</td>
</tr>
<tr>
<td>:fire: (火焰)</td>
<td><code>:fire:</code></td>
<td>移除代码或文件</td>
</tr>
<tr>
<td>:bug: (bug)</td>
<td><code>:bug:</code></td>
<td>修复 bug</td>
</tr>
<tr>
<td>:ambulance: (急救车)</td>
<td><code>:ambulance:</code></td>
<td>重要补丁</td>
</tr>
<tr>
<td>:sparkles: (火花)</td>
<td><code>:sparkles:</code></td>
<td>引入新功能</td>
</tr>
<tr>
<td>:memo: (备忘录)</td>
<td><code>:memo:</code></td>
<td>撰写文档</td>
</tr>
<tr>
<td>:rocket: (火箭)</td>
<td><code>:rocket:</code></td>
<td>部署功能</td>
</tr>
<tr>
<td>:lipstick: (口红)</td>
<td><code>:lipstick:</code></td>
<td>更新 UI 和样式文件</td>
</tr>
<tr>
<td>:tada: (庆祝)</td>
<td><code>:tada:</code></td>
<td>初次提交</td>
</tr>
<tr>
<td>:white_check_mark: (白色复选框)</td>
<td><code>:white_check_mark:</code></td>
<td>增加测试</td>
</tr>
<tr>
<td>:lock: (锁)</td>
<td><code>:lock:</code></td>
<td>修复安全问题</td>
</tr>
<tr>
<td>:apple: (苹果)</td>
<td><code>:apple:</code></td>
<td>修复 macOS 下的问题</td>
</tr>
<tr>
<td>:penguin: (企鹅)</td>
<td><code>:penguin:</code></td>
<td>修复 Linux 下的问题</td>
</tr>
<tr>
<td>:checkered_flag: (旗帜)</td>
<td><code>:checked_flag:</code></td>
<td>修复 Windows 下的问题</td>
</tr>
<tr>
<td>:bookmark: (书签)</td>
<td><code>:bookmark:</code></td>
<td>发行/版本标签</td>
</tr>
<tr>
<td>:rotating_light: (警车灯)</td>
<td><code>:rotating_light:</code></td>
<td>移除 linter 警告</td>
</tr>
<tr>
<td>:construction: (施工)</td>
<td><code>:construction:</code></td>
<td>工作进行中</td>
</tr>
<tr>
<td>:green_heart: (绿心)</td>
<td><code>:green_heart:</code></td>
<td>修复 CI 构建问题</td>
</tr>
<tr>
<td>:arrow_down: (下降箭头)</td>
<td><code>:arrow_down:</code></td>
<td>降级依赖</td>
</tr>
<tr>
<td>:arrow_up: (上升箭头)</td>
<td><code>:arrow_up:</code></td>
<td>升级依赖</td>
</tr>
<tr>
<td>:construction_worker: (工人)</td>
<td><code>:construction_worker:</code></td>
<td>添加 CI 构建系统</td>
</tr>
<tr>
<td>:chart_with_upwards_trend: (上升趋势图)</td>
<td><code>:chart_with_upwards_trend:</code></td>
<td>添加分析或跟踪代码</td>
</tr>
<tr>
<td>:hammer: (锤子)</td>
<td><code>:hammer:</code></td>
<td>重大重构</td>
</tr>
<tr>
<td>:heavy_minus_sign: (减号)</td>
<td><code>:heavy_minus_sign:</code></td>
<td>减少一个依赖</td>
</tr>
<tr>
<td>:whale: (鲸鱼)</td>
<td><code>:whale:</code></td>
<td>Docker 相关工作</td>
</tr>
<tr>
<td>:heavy_plus_sign: (加号)</td>
<td><code>:heavy_plug_sign:</code></td>
<td>增加一个依赖</td>
</tr>
<tr>
<td>:wrench: (扳手)</td>
<td><code>:wrench:</code></td>
<td>修改配置文件</td>
</tr>
<tr>
<td>:globe_with_meridians: (地球)</td>
<td><code>:globe_with_meridians:</code></td>
<td>国际化与本地化</td>
</tr>
<tr>
<td>:pencil2: (铅笔)</td>
<td><code>:pencil2:</code></td>
<td>修复 typo</td>
</tr>
</tbody></table>
</div></div><a class="button-hover more" href="/2020/10/07/git-emoji/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/10/07/esm/">深入理解 ES6 模块机制</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h1>前言</h1>
今天和同事一起讨论了ES6 模块机制，趁热打铁来复习下ES6 模块机制相关知识。

<p>在 ES6 中，我们知道 import、export 取代了 require、module.exports 用来引入和导出模块，但是如果不了解 ES6 模块特性的话，代码可能就会运行出一些匪夷所思的结果，下面我将通过这篇文章为你揭开 ES6 模块机制特点。</p>
<h1>ES6 模块特性</h1>

<p>说起 ES6 模块特性，那么就先说说 ES6 模块跟 CommonJS 模块的不同之处。</p>
<p>ES6 模块跟 CommonJS 模块的不同，主要有以下两个方面：</p>
<p>ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝<br>ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载<br>这个怎么理解呢？我们一步步来看：</p>
<h1>CommonJS 输出值的拷贝</h1>

<p>CommonJS 模块输出的是值的拷贝(原始值的拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo);</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">let foo &#x3D; 1;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码说明，b 模块加载以后，它的内部 foo 变化就影响不到输出的 exports.foo 了。这是因为 foo 是一个原始类型的值，会被缓存。所以如果你想要在 CommonJS 中动态获取模块中的值，那么就需要借助于函数延时执行的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo());</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo());</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo());</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">let foo &#x3D; 1;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    foo: () &#x3D;&gt; &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们可以总结一下：</p>
<p>CommonJS 模块重复引入的模块并不会重复执行，再次获取模块直接获得暴露的 module.exports 对象<br>如果你要处处获取到模块内的最新值的话，也可以你每次更新数据的时候每次都要去更新 module.exports 上的值<br>如果你暴露的 module.exports 的属性是个对象，那就不存在这个问题了<br>所以如果你要处处获取到模块内的最新值的话，也可以你每次更新数据的时候每次都要去更新 module.exports 上的值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo);</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">module.exports.foo &#x3D; 1;   &#x2F;&#x2F; 同 exports.foo &#x3D; 1 </span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    module.exports.foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1>ES6 输出值的引用</h1>  

<p>然而在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">console.log(foo);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    import(&#39;.&#x2F;b&#39;).then((&#123; foo &#125;) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(foo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1>ES6 静态编译，CommonJS 运行时加载</h1>

<p>关于第二点，ES6 模块编译时执行会导致有以下两个特点：</p>
<p>import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。<br>export 命令会有变量声明提前的效果。<br>import 优先执行:</p>
<p>从第一条来看，在文件中的任何位置引入 import 模块都会被提前到文件顶部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a.js&#39;)</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line">console.log(&#39;b.js 先执行&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果:</span><br><span class="line">&#x2F;&#x2F; b.js 先执行</span><br><span class="line">&#x2F;&#x2F; a.js</span><br></pre></td></tr></table></figure>
<p>从执行结果我们可以很直观地看出，虽然 a 模块中 import 引入晚于 console.log(‘a’)，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。</p>
<p>由于 import 是静态执行，所以 import 具有提升效果即 import 命令在模块中的位置并不影响程序的输出。</p>
<p>export 变量声明提升:</p>
<p>正常的引入模块是没办法看出变量声明提升的特性，需要通过循环依赖加载才能看出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;a.js&#39;);</span><br><span class="line">export const bar &#x3D; 1;</span><br><span class="line"></span><br><span class="line">export const bar2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;bar2&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function bar3() &#123;</span><br><span class="line">    console.log(&#39;bar3&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line">import * as a from &#39;.&#x2F;a&#39;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果:</span><br><span class="line">&#x2F;&#x2F; &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;</span><br><span class="line">&#x2F;&#x2F; a.js</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以很直观地看出，a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明的变量也是优于模块其它内容的执行的，但是具体对变量赋值需要等到执行到相应代码的时候。(当然函数声明和表达式声明不一样，这一点跟 JS 函数性质一样，这里就不过多解释)</p>
<p>好了，讲完了 ES6 模块和 CommonJS 模块的不同点之后，接下来就讲讲相同点：</p>
<p>模块不会重复执行</p>
<p>这个很好理解，无论是 ES6 模块还是 CommonJS 模块，当你重复引入某个相同的模块时，模块只会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#39;.&#x2F;b&#39;;</span><br><span class="line">import &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;只会执行一次&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 只会执行一次</span><br></pre></td></tr></table></figure>

<p>结合上面说的特性，我们来看一个比较经典的例子，循环依赖，当你理解了上面所讲的特性之后，下次遇到模块循环依赖代码的执行结果就很容易理解了。</p>
<h1>CommonJS 模块循环依赖</h1>

<p>先来看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(&#39;in a, b.done &#x3D;&#39;, b.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;a done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">console.log(&#39;in b, a.done &#x3D;&#39;, a.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;b done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; a starting</span><br><span class="line">&#x2F;&#x2F; b starting</span><br><span class="line">&#x2F;&#x2F; in b, a.done &#x3D; false</span><br><span class="line">&#x2F;&#x2F; b done</span><br><span class="line">&#x2F;&#x2F; in a, b.done &#x3D; true</span><br><span class="line">&#x2F;&#x2F; a done</span><br></pre></td></tr></table></figure>

<p>结合之前讲的特性很好理解，当你从 b 中想引入 a 模块的时候，因为 node 之前已经加载过 a 模块了，所以它不会再去重复执行 a 模块，而是直接去生成当前 a 模块吐出的 module.exports 对象，因为 a 模块引入 b 模块先于给 done 重新赋值，所以当前 a 模块中输出的 module.exports 中 done 的值仍为 false。而当 a 模块中输出 b 模块的 done 值的时候 b 模块已经执行完毕，所以 b 模块中的 done 值为 true。</p>
<p>从上面的执行过程中，我们可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。虽然这种模块加载机制可以避免出现循环依赖时报错的情况，但稍不注意就很可能使得代码并不是像我们想象的那样去执行。因此在写代码时还是需要仔细的规划，以保证循环模块的依赖能正确工作。</p>
<p>所以有什么办法可以出现循环依赖的时候避免自己出现混乱呢？一种解决方式便是将每个模块先写 exports 语法，再写 require语句，利用 CommonJS 的缓存机制，在 require() 其他模块之前先把自身要导出的内容导出，这样就能保证其他模块在使用时可以取到正确的值。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">let b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.done)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">let a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">console.log(a.done)</span><br></pre></td></tr></table></figure>

<p>这种写法简单明了，缺点是要改变每个模块的写法，而且大部分同学都习惯了在文件开头先写 require 语句。</p>
<h1>ES6 模块循环依赖</h1>

<p>跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a starting&#39;)</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;in b, foo:&#39;, foo);</span><br><span class="line">export const bar &#x3D; 2;</span><br><span class="line">console.log(&#39;a done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b starting&#39;);</span><br><span class="line">import &#123; bar &#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">export const foo &#x3D; &#39;foo&#39;;</span><br><span class="line">console.log(&#39;in a, bar:&#39;, bar);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;in a, setTimeout bar:&#39;, bar);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;b done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; b starting</span><br><span class="line">&#x2F;&#x2F; in a, bar: undefined</span><br><span class="line">&#x2F;&#x2F; b done</span><br><span class="line">&#x2F;&#x2F; a starting</span><br><span class="line">&#x2F;&#x2F; in b, foo: foo</span><br><span class="line">&#x2F;&#x2F; a done</span><br><span class="line">&#x2F;&#x2F; in a, setTimeout bar: 2</span><br></pre></td></tr></table></figure>

<h1>动态 import()</h1>

<p>ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(some condition) &#123;</span><br><span class="line">    import a from &#39;.&#x2F;a&#39;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    import b from &#39;.&#x2F;b&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; or </span><br><span class="line">import a from (str + &#39;b&#39;);</span><br></pre></td></tr></table></figure>

<p>因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入 import() 应运而生。</p>
<p>import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。</p>
<p>require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话 require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。<br>而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()<br>我们先来看下它的用法：</p>
<p>动态的 import() 提供一个基于 Promise 的 API<br>动态的import() 可以在脚本的任何地方使用<br>import() 接受字符串文字，你可以根据你的需要构造说明符<br>举个简单的使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">const str &#x3D; &#39;.&#x2F;b&#39;;</span><br><span class="line">const flag &#x3D; true;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">    import(&#39;.&#x2F;b&#39;).then((&#123;foo&#125;) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(foo);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">import(str).then((&#123;foo&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export const foo &#x3D; &#39;foo&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果</span><br><span class="line">&#x2F;&#x2F; foo</span><br><span class="line">&#x2F;&#x2F; foo</span><br></pre></td></tr></table></figure>

<p>当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。</p>
<p>因为是基于 Promise 的，所以如果你想要同时加载多个模块的话，可以是 Promise.all 进行并行异步加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">    import(&#39;.&#x2F;a.js&#39;),</span><br><span class="line">    import(&#39;.&#x2F;b.js&#39;),</span><br><span class="line">    import(&#39;.&#x2F;c.js&#39;),</span><br><span class="line">]).then(([a, &#123;default: b&#125;, &#123;c&#125;]) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;a.js is loaded dynamically&#39;);</span><br><span class="line">    console.log(&#39;b.js is loaded dynamically&#39;);</span><br><span class="line">    console.log(&#39;c.js is loaded dynamically&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还有 Promise.race 方法，它检查哪个 Promise 被首先 resolved 或 reject。我们可以使用import()来检查哪个CDN速度更快：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const CDNs &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;jQuery.com&#39;,</span><br><span class="line">        url: &#39;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;googleapis.com&#39;,</span><br><span class="line">        url: &#39;https:&#x2F;&#x2F;ajax.googleapis.com&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.1.1&#x2F;jquery.min.js&#39;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(&#96;------&#96;);</span><br><span class="line">console.log(&#96;jQuery is: $&#123;window.jQuery&#125;&#96;);</span><br><span class="line"></span><br><span class="line">Promise.race([</span><br><span class="line">    import(CDNs[0].url).then(()&#x3D;&gt;console.log(CDNs[0].name, &#39;loaded&#39;)),</span><br><span class="line">    import(CDNs[1].url).then(()&#x3D;&gt;console.log(CDNs[1].name, &#39;loaded&#39;))</span><br><span class="line">]).then(()&#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;jQuery version: $&#123;window.jQuery.fn.jquery&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果你觉得这样写还不够优雅，也可以结合 async/await 语法糖来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    const myModule &#x3D; await import(&#39;.&#x2F;myModule.js&#39;);</span><br><span class="line">    const &#123;export1, export2&#125; &#x3D; await import(&#39;.&#x2F;myModule.js&#39;);</span><br><span class="line">    const [module1, module2, module3] &#x3D;</span><br><span class="line">        await Promise.all([</span><br><span class="line">            import(&#39;.&#x2F;module1.js&#39;),</span><br><span class="line">            import(&#39;.&#x2F;module2.js&#39;),</span><br><span class="line">            import(&#39;.&#x2F;module3.js&#39;),</span><br><span class="line">        ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态 import() 为我们提供了以异步方式使用 ES 模块的额外功能。 根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。</p>
<h1>参考文章</h1>

<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33843378">https://zhuanlan.zhihu.com/p/33843378</a></p>
</div></div><a class="button-hover more" href="/2020/10/07/esm/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/10/07/first-blog/">first-blog</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-12-30</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="ideas"><a href="#ideas" class="headerlink" title="ideas"></a>ideas</h2><hr>
<ul>
<li>记录学习、生活中的点点滴滴</li>
</ul>
</div></div><a class="button-hover more" href="/2020/10/07/first-blog/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2020 By TheFirstSunday</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>