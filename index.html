<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法"><meta name="keywords" content="FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法"><meta name="author" content="TheFirstSunday,undefined"><meta name="copyright" content="TheFirstSunday"><title>coder【前端-FE】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"V5C7R11NIT","apiKey":"37d9271c02b1e0f2f42bd334f8f0de94","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {"appId":"EDiQLCtfYJFYtECr3Adwmncl-gzGzoHsz","appKey":"MDXLAYtR8IlmgStY29ElIjge","placeholder":"Just Go Go."},
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">TheFirstSunday</div><div class="author-info-description">FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/TheFirstSunday" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:zhaonan266366@163.com" target="_blank">Email<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2621940203&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">13</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">6</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">前端-FE</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2021/06/01/hello-world/">开启我的个人博客</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><p>the personal blog with Hexo, theme Fan. Record every bit of learning and life.</p>
</div></div><a class="button-hover more" href="/2021/06/01/hello-world/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/06/01/message/">四种跨浏览器选项卡实时通信方法</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><p>多年来，随着对 Web 应用程序的需求增多，Web 浏览器的功能也不断增强。从而，可以找到实现类似功能的多种方法。本文将介绍一类很少被人关注的功能：在浏览器选项卡之间进行通信。以下是列举的几个适用场景：</p>
<ul>
<li>将对应用程序的主题修改（例如，深色或浅色主题）应用到所有已打开的浏览器选项卡中。</li>
<li>请求用于身份验证的最新令牌，并在浏览器选项卡之间共享。</li>
<li>跨浏览器选项卡同步应用程序状态。</li>
</ul>
<p>本文主要介绍几种跨浏览器通信的方法。然而，每种方法都有其优缺点。因此，本文会详细讨论它们，以便让您能够在实际开发中找到适用的最佳方法。</p>
<ol>
<li>使用本地存储事件 LocalStorage</li>
</ol>
<p>通过使用 LocalStorage，可以使得同一应用程序源中的选项卡之间进行通信。同时 LocalStorage 也支持事件，可以使用此功能跨浏览器选项卡进行通信，存储更新后，其他选项卡将接收事件。</p>
<p>例如，在一个选项卡中执行以下 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&quot;theme&quot;, &quot;dark&quot;);</span><br></pre></td></tr></table></figure>

<p>如下所示，监听事件的其他选项卡将接收它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (event.storageArea !&#x3D; localStorage) return;</span><br><span class="line">    if (event.key &#x3D;&#x3D;&#x3D; &#39;theme&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 测试使用 event.newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/bold-hoover-ol2jz?file=/index.html">codesandbox demo</a></p>
<ol start="2">
<li>使用 BroadcastChannel API 接口</li>
</ol>
<p>BroadcastChannel API 允许选项卡、窗口、Frames、Iframes 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a> 之间的通信。一个选项卡可以创建一个 Channel 并在其中发送消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new BroadcastChannel(&#39;app-data&#39;);</span><br><span class="line">channel.postMessage(&#39;post&#39;);</span><br></pre></td></tr></table></figure>

<p>其他选项卡可以监听频道，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new BroadcastChannel(&#39;app-data&#39;);</span><br><span class="line"></span><br><span class="line">channel.addEventListener (&#39;message&#39;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Disconnect the channel</span><br><span class="line">channel.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/white-hooks-9l081?file=/index.html">codesandbox demo</a></p>
<p>这样，浏览器上下文（<strong>Windows、Tabs、Frames、或 Iframes</strong>）之间可以进行通信。尽管这是浏览器选项卡之间的一种很便捷的通信方式，但 safari 和 IE 是不支持这种方式的。可以在 MDN 的 BroadcastChannel 文档中查看详细信息。</p>
<ol start="3">
<li>使用 Service Worker 发送消息</li>
</ol>
<p>可能会有疑问，Service Worker 是如何进入这种场景的。不过从根本上来说，Service Worker 支持发送消息，可以使用这些消息在浏览器选项卡之间进行通信。<br>使用 Service Worker，可以发送如下所示的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.controller.postMessage(&#123;</span><br><span class="line">    broadcast: data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时在接收 Worker 的其他浏览器选项卡中可以监听事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(&#39;message&#39;, async (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (&#39;boadcast&#39; in event.data ) &#123;</span><br><span class="line">        const allClients &#x3D; await clients.matchAll();</span><br><span class="line">        for (const client of allClients) &#123;</span><br><span class="line">            client.postMessage(event.broadcast);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方法提供更多的控制保障，是传递消息的可靠方法。但是，实现 Service Worker 需要一些关于 Service Worker API 的补充知识和额外工作。所以，在这种情况下，如果其他方法都不起作用，最好还是尝试这个方法。可以在 MDN 的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration">Service Worker API</a> 文档中找到更多信息，还有一个完整的示例。</p>
<ol start="4">
<li>使用 Service Worker 发送消息</li>
</ol>
<p>Window.postMessage() 方法是跨浏览器选项卡、弹出窗口和 Iframes 进行通信的传统方法之一。可以按如下方式发送消息.<br><strong>Syntax</strong><br>targetWindow.postMessage(message, targetOrigin, [transfer]);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const targetWindow &#x3D; window.opener;</span><br><span class="line">targetWindow.postMessage(message, targetOrigin)</span><br></pre></td></tr></table></figure>

<p>目标窗口可以监听事件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;, (event) &#x3D;&gt; &#123;</span><br><span class="line">    if (event.origin !&#x3D;&#x3D; &quot;http:&#x2F;&#x2F;localhost:8080&quot;) return;</span><br><span class="line">    &#x2F;&#x2F; 可以做测试</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>与其他方法相比，这种方法有一个优点：可以支持跨源通信。但它也有一个限制：需要引用另一个浏览器选项卡。所以这种方法只适用于通过 window.open() 或 document.open() 方法。可以在 MDN 文档中找到更多信息。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/gallant-mendeleev-jnbuo?file=/index.html">codesandbox demo</a></p>
</div></div><a class="button-hover more" href="/2021/06/01/message/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/03/22/nopassword/">mac/ubuntu/linux 配置sudo免密码</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Mac/">Mac</a></div></div><div class="post-content"><div class="main-content content"><h2 id="mac-ubuntu-linux-配置sudo免密码"><a href="#mac-ubuntu-linux-配置sudo免密码" class="headerlink" title="mac/ubuntu/linux 配置sudo免密码"></a>mac/ubuntu/linux 配置sudo免密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 打开命令窗口输入如下命令：</span><br><span class="line">sudo visudo 或者  sudo vi /etc/sudoers</span><br><span class="line">2 替换 #%admin ALL=(ALL) ALL 为</span><br><span class="line"><span class="meta">%</span><span class="bash">admin ALL=(ALL) NOPASSWD: NOPASSWD: ALL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></div><a class="button-hover more" href="/2021/03/22/nopassword/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2021/03/18/javascriptFeatures/">JavaScript features in 2021</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div><div class="post-content"><div class="main-content content"><p>在撰写本文时，以下新的JavaScript提案功能已进入第4阶段，并且几乎肯定会包含在ES2021中。您已经可以开始在<a target="_blank" rel="noopener" href="https://kangax.github.io/compat-table/es2016plus/">最新版本的浏览器，Node.js和Babel中使用</a>。</p>
<p>注意：ECMAScript是JavaScript所基于的标准，由TC39委员会管理。ECMAScript始终是一个不需要的名称，这会使所有内容对初学者都感到困惑。人们经常谈论JavaScript功能，但参考的是ECMAScript规范。</p>
<h2 id="Numeric-Separators"><a href="#Numeric-Separators" class="headerlink" title="Numeric Separators"></a>Numeric Separators</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>_000_000_000 <span class="comment">// decimal literals</span></span><br><span class="line"><span class="number">0b1010</span>_0001 <span class="comment">// binary literals</span></span><br><span class="line"><span class="number">101</span>_475_938<span class="number">.38</span> <span class="comment">// floating-point literals</span></span><br><span class="line"><span class="number">0.000</span>_001 <span class="comment">// in fractional part</span></span><br><span class="line"><span class="number">1e10</span>_000 <span class="comment">// in exponent part</span></span><br></pre></td></tr></table></figure>

<h2 id="Logical-Assignment"><a href="#Logical-Assignment" class="headerlink" title="Logical Assignment"></a>Logical Assignment</h2><p>支持与新的运营逻辑分配 &amp;&amp;=，||= 和 ??=。与它们的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators">mathematical and bitwise counterparts</a>不同，逻辑分配遵循其各自逻辑操作的短路行为。仅当逻辑运算将评估右侧时，它们才执行分配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// falsy: false, 0, -0, 0n, &quot;&quot;, null, undefined, and NaN</span></span><br><span class="line"><span class="comment">// truthy: all values are truthy unless defined as falsy</span></span><br><span class="line"><span class="comment">// nullish: null or undefined</span></span><br><span class="line"></span><br><span class="line">a ||= b</span><br><span class="line"><span class="comment">// Logical OR assignment</span></span><br><span class="line"><span class="comment">// Equivalent to: a || (a = b);</span></span><br><span class="line"><span class="comment">// Only assigns if a is falsy</span></span><br><span class="line"></span><br><span class="line">a &amp;&amp;= b</span><br><span class="line"><span class="comment">// Logical AND assignment</span></span><br><span class="line"><span class="comment">// Equivalent to: a &amp;&amp; (a = b);</span></span><br><span class="line"><span class="comment">// Only assigns if a is truthy</span></span><br><span class="line"></span><br><span class="line">a ??= b</span><br><span class="line"><span class="comment">// Logical nullish assignment</span></span><br><span class="line"><span class="comment">// Equivalent to: a ?? (a = b);</span></span><br><span class="line"><span class="comment">// Only assigns if a is nullish</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// examples: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical Assignment Operator with &amp;&amp; operator</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">a &amp;&amp;= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"><span class="comment">// 1. a &amp;&amp; (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (a) a = b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical Assignment Operator with || operator</span></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">a ||= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"><span class="comment">// 1. a || (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (!a) a = b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical Assignment Operator with ?? operator</span></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"><span class="comment">// a ?? (a = b)</span></span><br></pre></td></tr></table></figure>

<h2 id="Weak-references-and-finalizers"><a href="#Weak-references-and-finalizers" class="headerlink" title="Weak references and finalizers"></a>Weak references and finalizers</h2><p>此功能包含两个高级对象WeakRef和FinalizationRegistry。根据使用情况，这些接口可以单独使用，也可以一起使用。正确使用它们需要仔细考虑，如果可能，最好避免使用它们。</p>
<p>WeakRef 是一个更高级的 API，它提供了真正的弱引用，Weakref 实例具有一个方法 deref，该方法返回被引用的原始对象，如果原始对象已被收集，则返回 undefined 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create a WeakRef object referring to a given target object</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="keyword">new</span> WeakRef(targetObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the WeakRef instance&#x27;s target object, or undefined if the target object has been garbage-collected</span></span><br><span class="line"><span class="keyword">const</span> obj = ref.deref()</span><br></pre></td></tr></table></figure>

<p>使用FinalizationRegistry对象可以在垃圾回收对象时请求回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create a registry object that uses the given callback</span></span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> FinalizationRegistry([callback])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register an object with a registry instance so that if the object is garbage-collected, the registry&#x27;s callback may get called</span></span><br><span class="line">registry.register(target, heldValue, [unregisterToken])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unregister a target object from a registry instance</span></span><br><span class="line">registry.unregister(unregisterToken)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>Promise.any 方法和 Promise.race 类似——只要给定的迭代中的一个 promise 成功，就采用第一个 promise 的值作为它的返回值，但与 Promise.race 的不同之处在于——它会等到所有 promise 都失败之后，才返回失败的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any(promises).then(</span><br><span class="line">    (first) =&gt; &#123;</span><br><span class="line">        <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">        <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">        <span class="comment">// error instanceof AggregateError</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-replaceAll"><a href="#String-prototype-replaceAll" class="headerlink" title="String.prototype.replaceAll"></a>String.prototype.replaceAll</h2><p>当前，如果不使用全局正则表达式，就无法替换字符串中子字符串的所有实例。与字符串参数一起使用时，String.prototype.replace仅影响首次出现。</p>
<p>String.prototype.replaceAll() 将为开发人员提供一种简单的方法来完成此常见的基本操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;139****1234&#x27;</span>.replaceAll(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;x&#x27;</span>) <span class="comment">// &#x27;139xxxx1234&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcabc&#x27;</span>.replaceAll(<span class="regexp">/b/g</span>, <span class="string">&#x27;A&#x27;</span>) <span class="comment">// &#x27;aAcaAc&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://ageek.dev/js-numeric-separators">数字分隔符</a><br><a target="_blank" rel="noopener" href="https://ageek.dev/js-logical-assignment">逻辑分配</a><br><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-weakrefs">Weak references and finalizers</a><br><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-any">Promose.any()</a><br><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-string-replaceall">String.prototype.replaceAll()</a></p>
</div></div><a class="button-hover more" href="/2021/03/18/javascriptFeatures/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/28/arrow/">心情烦躁、画个箭头吧</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/CSS3/">CSS3</a></div></div><div class="post-content"><div class="main-content content"><h2 id="CSS3实现右侧箭头-烦躁、画个箭头消消火"><a href="#CSS3实现右侧箭头-烦躁、画个箭头消消火" class="headerlink" title="CSS3实现右侧箭头(烦躁、画个箭头消消火)"></a>CSS3实现右侧箭头(烦躁、画个箭头消消火)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right-arrow&#x27;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 实现方式一 --&gt;</span><br><span class="line">width: 8px;</span><br><span class="line">height: 8px;</span><br><span class="line">border-bottom: 2px solid rgba(255, 255, 255, 0.7);</span><br><span class="line">border-right: 2px solid rgba(255, 255, 255, 0.7);</span><br><span class="line">transform: matrix(0.71, -0.7, 0.71, 0.71, 0, 0);</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 实现方式二 --&gt;</span><br><span class="line">width: 8px;</span><br><span class="line">height: 8px;</span><br><span class="line">border-bottom: 2px solid rgba(255, 255, 255, 0.7);</span><br><span class="line">border-right: 2px solid rgba(255, 255, 255, 0.7);</span><br><span class="line">transform: rotate(45deg);</span><br></pre></td></tr></table></figure>
</div></div><a class="button-hover more" href="/2020/12/28/arrow/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/28/caseSensitivity/">git 解决远程仓库文件大小写问题</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><h2 id="记解决远程仓库文件大小"><a href="#记解决远程仓库文件大小" class="headerlink" title="记解决远程仓库文件大小"></a>记解决远程仓库文件大小</h2><p>在React我们习惯把组件文件首字母定为大写，但是今天发现有同事弄了一个骚操作</p>
<img src="/2020/12/28/caseSensitivity/caseSensitivity.png" class="" title="This is an image">

<p>大概是这个样子</p>
<ul>
<li>新建一个 setting.ts 文件(大小写不敏感的状态下)，并提交</li>
<li>修改本地 setting.ts 变为 Setting.ts，文件内容无变更，无法提交</li>
<li>执行git config core.ignorecase false，修改 大小写敏感 规则，然后提交，查看结果，此时会存在 大小写 同时存在的文件</li>
<li>此时某种机缘下，再次执行 git config core.ignorecase true，大小写不敏感，</li>
<li>此时执行 git push ， 即把最新的更新都更新到了 a.ts 中</li>
<li>此时再修改 大小写敏感规则为敏感， 执行 git pull ，并不会拿到最新的更新。比如自己想要的是第一次修改后的 Setting.ts ，但是服务器有一个没有更新的 Setting.ts 和 有更新的 setting.ts,而你只能拿到前者，这可能就会出现一些问题</li>
</ul>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>执行git config –global core.ignorecase false，全局设置 大小写敏感 。</p>
<ol>
<li><p>文件变更比较少的情况</p>
<p> 直接使用以下命令重命名文件，在 git 中不要直接修改文件名，最好的办法是使用下面的方式，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git mv -f [你想要删掉的文件] [你想要留下的文件]</span><br><span class="line">git mv -f setting.ts Setting.ts</span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"></span><br><span class="line">git rm setting.ts</span><br><span class="line">git add Setting.ts</span><br></pre></td></tr></table></figure>

<p> 这个命令的目的就是删除不需要的大小写同名文件，修改后 git push 提交变更即可。</p>
<p> 或</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git rm --cached src&#x2F;...&#x2F;setting -r</span><br></pre></td></tr></table></figure>
</li>
<li><p>变更比较多时</p>
<ul>
<li>删除远程分支</li>
<li>本地执行 git rm -r –cached .</li>
<li>然后重新 git push</li>
</ul>
<p>mac windows 在不设置大小写敏感规则的时候默认大小写是不敏感，项目部署的机器是 Linux 的，而 Linux 是大小写敏感的。所以这样的问题平时不易发现，本地调试的时候大部分时候并不会出错误，只有在项目部署的时候问题才会显示出来</p>
</li>
</ol>
</div></div><a class="button-hover more" href="/2020/12/28/caseSensitivity/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/06/fiber/">React Fiber</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="转载-前端工程师的自我修养：React-Fiber-是如何实现更新过程可控的"><a href="#转载-前端工程师的自我修养：React-Fiber-是如何实现更新过程可控的" class="headerlink" title="(转载) 前端工程师的自我修养：React Fiber 是如何实现更新过程可控的"></a>(转载) 前端工程师的自我修养：React Fiber 是如何实现更新过程可控的</h2><p>原文地址: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6911681589558640654?utm_source=gold_browser_extension">https://juejin.cn/post/6911681589558640654?utm_source=gold_browser_extension</a></p>
<p>前言<br>从 React 16 开始，React 采用了 Fiber 机制替代了原先基于原生执行栈递归遍历 VDOM 的方案，提高了页面渲染性能和用户体验。乍一听 Fiber 好像挺神秘，在原生执行栈都还没搞懂的情况下，又整出个 Fiber，还能不能愉快的写代码了。别慌，老铁！下面就来唠唠关于 Fiber 那点事儿。</p>
<h3 id="什么是-Fiber"><a href="#什么是-Fiber" class="headerlink" title="什么是 Fiber"></a>什么是 Fiber</h3><p>Fiber 的英文含义是“纤维”，它是比线程（Thread）更细的线，比线程（Thread）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（Cooperative）编程模型，帮助开发者用一种【既模块化又协作化】的方式来编排代码。</p>
<p>简单点说，Fiber 就是 React 16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前一竿子递归到底影响性能的做法。</p>
<h3 id="关于-Fiber-你需要知道的基础知识"><a href="#关于-Fiber-你需要知道的基础知识" class="headerlink" title="关于 Fiber 你需要知道的基础知识"></a>关于 Fiber 你需要知道的基础知识</h3><p>1.浏览器刷新率（帧）<br>页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16ms 左右。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。那么在这一帧的（16ms） 过程中浏览器又干了啥呢？<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2eea940e124be2973989154948d049~tplv-k3u1fbpfcp-zoom-1.image" alt="一帧图片"></p>
<p>通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程：</p>
<ul>
<li>接受输入事件</li>
<li>执行事件回调</li>
<li>开始一帧</li>
<li>执行 RAF (RequestAnimationFrame)</li>
<li>页面布局，样式计算</li>
<li>渲染</li>
<li>执行 RIC  (RequestIdelCallback)</li>
</ul>
<p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。这里提一下，如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。<br>2. JS 原生执行栈<br>React Fiber 出现之前，React 通过原生执行栈递归遍历 VDOM。当浏览器引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并将其压入执行栈，接下来每遇到一个函数调用，又会往栈中压入一个新的上下文。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    B();</span><br><span class="line">    C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br></pre></td></tr></table></figure>

<p>引擎在执行的时候，会形成如下这样的执行栈:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9177f8e0d59d4971bdc226fc46df3b65~tplv-k3u1fbpfcp-zoom-1.image" alt="执行栈图片"></p>
<p>浏览器引擎会从执行栈的顶端开始执行，执行完毕就弹出当前执行上下文，开始执行下一个函数，直到执行栈被清空才会停止。然后将执行权交还给浏览器。由于 React 将页面视图视作一个个函数执行的结果。每一个页面往往由多个视图组成，这就意味着多个函数的调用。<br>如果一个页面足够复杂，形成的函数调用栈就会很深。每一次更新，执行栈需要一次性执行完成，中途不能干其他的事儿，只能”一心一意”。结合前面提到的浏览器刷新率，JS 一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制。如果这个时间超过 16ms，当页面有动画效果需求时，动画因为浏览器不能及时绘制下一帧，这时动画就会出现卡顿。不仅如此，因为事件响应代码是在每一帧开始的时候执行，如果不能及时绘制下一帧，事件响应也会延迟。<br>3. 时间分片（Time Slicing）<br>时间分片指的是一种将多个粒度小的任务放入一个时间切片（一帧）中执行的一种方案，在 React Fiber 中就是将多个任务放在了一个时间片中去执行。<br>4. 链表<br>在 React Fiber 中用链表遍历的方式替代了 React 16 之前的栈递归方案。在 React 16 中使用了大量的链表。例如：</p>
<p>使用多向链表的形式替代了原来的树结构</p>
<p>例如下面这个组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    A1</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B1&quot;</span>&gt;</span></span><br><span class="line">        B1</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;C1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span><br><span class="line">        B2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>会使用下面这样的链表表示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/094d4f8810d4473fbd1ebcea594073dd~tplv-k3u1fbpfcp-zoom-1.image" alt="链表"></p>
</li>
<li><p>副作用单链表</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1180ed8b2b104309bcb907e6a647de01~tplv-k3u1fbpfcp-zoom-1.image" alt="副租用单链表"></p>
<ul>
<li>状态更新单链表</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d543c88f1b9f45a48f6181ce76959690~tplv-k3u1fbpfcp-zoom-1.image" alt="状态更新单链表"><br>…</p>
<p>链表是一种简单高效的数据结构，它在当前节点中保存着指向下一个节点的指针，就好像火车一样一节连着一节</p>
<p>-遍历的时候，通过操作指针找到下一个元素。但是操作指针时（调整顺序和指向）一定要小心。<br>链表相比顺序结构数据格式的好处就是：</p>
<ul>
<li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。</li>
<li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。</li>
</ul>
<p>但链表也不是完美的，缺点就是：</p>
<ul>
<li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。</li>
<li>不能自由读取，必须找到他的上一个节点。</li>
</ul>
<p>React 用空间换时间，更高效的操作可以方便根据优先级进行操作。同时可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用。</p>
<h3 id="React-Fiber-是如何实现更新过程可控？"><a href="#React-Fiber-是如何实现更新过程可控？" class="headerlink" title="React Fiber 是如何实现更新过程可控？"></a>React Fiber 是如何实现更新过程可控？</h3><p>前面讲完基本知识，现在正式开始介绍今天的主角 Fiber，看看 React Fiber 是如何实现对更新过程的管控。</p>
<p>更新过程的可控主要体现在下面几个方面:</p>
<ul>
<li>任务拆分</li>
<li>任务挂起、恢复、终止</li>
<li>任务具备优先级</li>
</ul>
<ol>
<li>任务拆分<br>前面提到，React Fiber 之前是基于原生执行栈，每一次更新操作会一直占用主线程，直到更新完成。这可能会导致事件响应延迟，动画卡顿等现象。<br>在 React Fiber 机制中，它采用”化整为零”的战术，将调和阶段（Reconciler）递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责一个节点的处理。例如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span></span><br><span class="line"><span class="keyword">const</span> jsx = (</span><br><span class="line">    &lt;div id=<span class="string">&quot;A1&quot;</span>&gt;</span><br><span class="line">            A1</span><br><span class="line">        &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">            B1</span><br><span class="line">            &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;C1&lt;/div&gt;</span><br><span class="line">            &lt;div id=<span class="string">&quot;C2&quot;</span>&gt;C2&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;B2&quot;</span>&gt;B2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">ReactDom.render(jsx,<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>这个组件在渲染的时候会被分成八个小任务，每个任务用来分别处理 A1(div)、A1(text)、B1(div)、B1(text)、C1(div)、C1(text)、C2(div)、C2(text)、B2(div)、B2(text)。再通过时间分片，在一个时间片中执行一个或者多个任务。这里提一下，所有的小任务并不是一次性被切分完成，而是处理当前任务的时候生成下一个任务，如果没有下一个任务生成了，就代表本次渲染的 Diff 操作完成。</p>
<h3 id="挂起、恢复、终止"><a href="#挂起、恢复、终止" class="headerlink" title="挂起、恢复、终止"></a>挂起、恢复、终止</h3><p>再说挂起、恢复、终止之前，不得不提两棵 Fiber 树，workInProgress tree 和 currentFiber tree。<br>workInProgress 代表当前正在执行更新的 Fiber 树。在 render 或者 setState 后，会构建一颗 Fiber 树，也就是 workInProgress tree，这棵树在构建每一个节点的时候会收集当前节点的副作用，整棵树构建完成后，会形成一条完整的副作用链。<br>currentFiber 表示上次渲染构建的 Fiber 树。在每一次更新完成后 workInProgress 会赋值给  currentFiber。在新一轮更新时 workInProgress tree 再重新构建，新 workInProgress 的节点通过 alternate 属性和 currentFiber 的节点建立联系。<br>在新 workInProgress tree 的创建过程中，会同 currentFiber 的对应节点进行 Diff 比较，收集副作用。同时也会复用和 currentFiber 对应的节点对象，减少新创建对象带来的开销。也就是说无论是创建还是更新，挂起、恢复以及终止操作都是发生在 workInProgress tree 创建过程中。workInProgress tree  构建过程其实就是循环的执行任务和创建下一个任务，大致过程如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6051a82ff5604046a11a80c6fe0d4d00~tplv-k3u1fbpfcp-zoom-1.image" alt="process"></p>
<p>当没有下一个任务需要执行的时候，workInProgress tree 构建完成，开始进入提交阶段，完成真实 DOM 更新。<br>在构建 workInProgressFiber tree 过程中可以通过挂起、恢复和终止任务，实现对更新过程的管控。下面简化了一下源码，大致实现如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitWork = <span class="literal">null</span>;<span class="comment">//下一个执行单元</span></span><br><span class="line"><span class="comment">//开始调度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">    nextUnitWork = task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环执行工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;<span class="comment">//是否要让出时间片交出控制权</span></span><br><span class="line">    <span class="keyword">while</span>(nextUnitWork &amp;&amp; !shouldYield)&#123;</span><br><span class="line">        nextUnitWork = performUnitWork(nextUnitWork)</span><br><span class="line">        shouldYield = deadline.timeRemaining()&lt;<span class="number">1</span> <span class="comment">// 没有时间了，检出控制权给浏览器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitWork) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;所有任务完成&quot;</span>)</span><br><span class="line">        <span class="comment">//commitRoot() //提交更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有任务，但是交出控制权后,请求下次调度</span></span><br><span class="line">    requestIdleCallback(workLoop,&#123;<span class="attr">timeout</span>:<span class="number">5000</span>&#125;) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 处理一个小任务，其实就是一个 Fiber 节点，如果还有任务就返回下一个需要处理的任务，没有就代表整个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitWork</span>(<span class="params">currentFiber</span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> FiberNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>挂起</li>
</ul>
<p>当第一个小任务完成后，先判断这一帧是否还有空闲时间，没有就挂起下一个任务的执行，记住当前挂起的节点，让出控制权给浏览器执行更高优先级的任务。</p>
<ul>
<li>恢复<br>在浏览器渲染完一帧后，判断当前帧是否有剩余时间，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。这样完美的解决了调和过程一直占用主线程的问题。<br>那么问题来了他是如何判断一帧是否有空闲时间的呢？答案就是我们前面提到的 RIC (RequestIdleCallback) 浏览器原生 API，React 源码中为了兼容低版本的浏览器，对该方法进行了 Polyfill。<br>当恢复执行的时候又是如何知道下一个任务是什么呢？答案在前面提到的链表。在 React Fiber 中每个任务其实就是在处理一个 FiberNode 对象，然后又生成下一个任务需要处理的 FiberNode。顺便提一嘴，这里提到的FiberNode 是一种数据格式，下面是它没有开美颜的样子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(tag, pendingProps, key, mode) &#123;</span><br><span class="line">        <span class="comment">// 实例属性</span></span><br><span class="line">        <span class="built_in">this</span>.tag = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">        <span class="built_in">this</span>.key = key; <span class="comment">// react 元素上的 key 就是 jsx 上写的那个 key ，也就是最终 ReactElement 上的</span></span><br><span class="line">        <span class="built_in">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// createElement的第一个参数，ReactElement 上的 type</span></span><br><span class="line">        <span class="built_in">this</span>.type = <span class="literal">null</span>; <span class="comment">// 表示fiber的真实类型 ，elementType 基本一样，在使用了懒加载之类的功能时可能会不一样</span></span><br><span class="line">        <span class="built_in">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象</span></span><br><span class="line">        <span class="comment">// fiber</span></span><br><span class="line">        <span class="built_in">this</span>.return = <span class="literal">null</span>; <span class="comment">// 父节点，指向上一个 fiber</span></span><br><span class="line">        <span class="built_in">this</span>.child = <span class="literal">null</span>; <span class="comment">// 子节点，指向自身下面的第一个 fiber</span></span><br><span class="line">        <span class="built_in">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 兄弟组件, 指向一个兄弟节点</span></span><br><span class="line">        <span class="built_in">this</span>.index = <span class="number">0</span>; <span class="comment">//  一般如果没有兄弟节点的话是0 当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff</span></span><br><span class="line">        <span class="built_in">this</span>.ref = <span class="literal">null</span>; <span class="comment">// reactElement 上的 ref 属性</span></span><br><span class="line">        <span class="built_in">this</span>.pendingProps = pendingProps; <span class="comment">// 新的 props</span></span><br><span class="line">        <span class="built_in">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">// 旧的 props</span></span><br><span class="line">        <span class="built_in">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">// fiber 上的更新队列执行一次 setState 就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新</span></span><br><span class="line">        <span class="built_in">this</span>.memoizedState = <span class="literal">null</span>; <span class="comment">// 对应  memoizedProps，上次渲染的 state，相当于当前的 state，理解成 prev 和 next 的关系</span></span><br><span class="line">        <span class="built_in">this</span>.mode = mode; <span class="comment">// 表示当前组件下的子组件的渲染方式</span></span><br><span class="line">        <span class="comment">// effects</span></span><br><span class="line">        <span class="built_in">this</span>.effectTag = NoEffect; <span class="comment">// 表示当前 fiber 要进行何种更新</span></span><br><span class="line">        <span class="built_in">this</span>.nextEffect = <span class="literal">null</span>; <span class="comment">// 指向下个需要更新的fiber</span></span><br><span class="line">        <span class="built_in">this</span>.firstEffect = <span class="literal">null</span>; <span class="comment">// 指向所有子节点里，需要更新的 fiber 里的第一个</span></span><br><span class="line">        <span class="built_in">this</span>.lastEffect = <span class="literal">null</span>; <span class="comment">// 指向所有子节点中需要更新的 fiber 的最后一个</span></span><br><span class="line">        <span class="built_in">this</span>.expirationTime = NoWork; <span class="comment">// 过期时间，代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">        <span class="built_in">this</span>.childExpirationTime = NoWork; <span class="comment">// child 过期时间</span></span><br><span class="line">        <span class="built_in">this</span>.alternate = <span class="literal">null</span>; <span class="comment">// current 树和 WorkInProgress 树之间的相互引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额…看着好像有点上头，这是开了美颜的样子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae2b97cdc0b745c296a6e81b4fe8ba88~tplv-k3u1fbpfcp-zoom-1.image" alt="FiberNode"></p>
<p>是不是好看多了？在每次循环的时候，找到下一个执行需要处理的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitWork</span>(<span class="params">currentFiber</span>)</span>&#123;</span><br><span class="line"><span class="comment">//beginWork(currentFiber) //找到儿子，并通过链表的方式挂到currentFiber上，每一偶儿子就找后面那个兄弟</span></span><br><span class="line">    <span class="comment">//有儿子就返回儿子</span></span><br><span class="line">    <span class="keyword">if</span>(currentFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.child;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有儿子，则找弟弟</span></span><br><span class="line">    <span class="keyword">while</span>(currentFiber)&#123;<span class="comment">//一直往上找</span></span><br><span class="line">        <span class="comment">//completeUnitWork(currentFiber);//将自己的副作用挂到父节点去</span></span><br><span class="line">        <span class="keyword">if</span>(currentFiber.sibling)&#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.sibling</span><br><span class="line">        &#125;</span><br><span class="line">        currentFiber = currentFiber.return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次任务结束后返回该处理节点的子节点或兄弟节点或父节点。只要有节点返回，说明还有下一个任务，下一个任务的处理对象就是返回的节点。通过一个全局变量记住当前任务节点，当浏览器再次空闲的时候，通过这个全局变量，找到它的下一个任务需要处理的节点恢复执行。就这样一直循环下去，直到没有需要处理的节点返回，代表所有任务执行完成。最后大家手拉手，就形成了一颗 Fiber 树。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12f5f56f28c34ae7b25de07e36996830~tplv-k3u1fbpfcp-zoom-1.image" alt="Fiber Tree"></p>
<ul>
<li>终止<br>其实并不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断是否有优先级更高的执行任务，如果有就终止原来将要执行的任务，开始新的 workInProgressFiber 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是在 React 16 以后生命周期函数 componentWillMount 有可能会执行多次的原因。</li>
</ul>
<ol>
<li>任务具备优先级<br>React Fiber 除了通过挂起，恢复和终止来控制更新外，还给每个任务分配了优先级。具体点就是在创建或者更新 FiberNode 的时候，通过算法给每个任务分配一个到期时间（expirationTime）。在每个任务执行的时候除了判断剩余时间，如果当前处理节点已经过期，那么无论现在是否有空闲时间都必须执行改任务。</li>
</ol>
<p>同时过期时间的大小还代表着任务的优先级。<br>任务在执行过程中顺便收集了每个 FiberNode 的副作用，将有副作用的节点通过 firstEffect、lastEffect、nextEffect 形成一条副作用单链表 AI(TEXT)-B1(TEXT)-C1(TEXT)-C1-C2(TEXT)-C2-B1-B2(TEXT)-B2-A。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ae8e1febebe49be932fc071181ca9ed~tplv-k3u1fbpfcp-zoom-1.image" alt="副作用单链表"></p>
<p>其实最终都是为了收集到这条副作用链表，有了它，在接下来的渲染阶段就通过遍历副作用链完成 DOM 更新。这里需要注意，更新真实 DOM 的这个动作是一气呵成的，不能中断，不然会造成视觉上的不连贯。<br>关于 React Fiber 的思考</p>
<ol>
<li>能否使用生成器（generator）替代链表<br>在 Fiber 机制中，最重要的一点就是需要实现挂起和恢复，从实现角度来说 generator 也可以实现。那么为什么官方没有使用 generator 呢？猜测应该是是性能方面的原因。生成器不仅让您在堆栈的中间让步，还必须把每个函数包装在一个生成器中。一方面增加了许多语法方面的开销，另外还增加了任何现有实现的运行时开销。性能上远没有链表的方式好，而且链表不需要考虑浏览器兼容性。</li>
<li>Vue 是否会采用 Fiber 机制来优化复杂页面的更新<br>这个问题其实有点搞事情，如果 Vue 真这么做了是不是就是变相承认 Vue 是在”集成” Angular 和 React 的优点呢？React 有 Fiber，Vue 就一定要有？<br>两者虽然都依赖 DOM Diff，但是实现上且有区别，DOM Diff 的目的都是收集副作用。Vue 通过 Watcher 实现了依赖收集，本身就是一种很好的优化。所以 Vue 没有采用 Fiber 机制，也无伤大雅。<br>总结<br>React Fiber 的出现相当于是在更新过程中引进了一个中场指挥官，负责掌控更新过程，足球世界里管这叫前腰。抛开带来的性能和效率提升外，这种“化整为零”和任务编排的思想，可以应用到我们平时的架构设计中。</li>
</ol>
<p>作者：政采云前端团队<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6911681589558640654">https://juejin.cn/post/6911681589558640654</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div></div><a class="button-hover more" href="/2020/12/06/fiber/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/12/02/concurrency/">concurrency</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="转载-如何利用-JavaScript-实现并发控制"><a href="#转载-如何利用-JavaScript-实现并发控制" class="headerlink" title="(转载) 如何利用 JavaScript 实现并发控制"></a>(转载) 如何利用 JavaScript 实现并发控制</h2><p>原文地址: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6912220538286899207?utm_source=gold_browser_extension#heading-4">https://juejin.cn/post/6912220538286899207?utm_source=gold_browser_extension#heading-4</a><br>引申出的FixedArray、HashTable值得大家了解下</p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>  在开发过程中，有时会遇到需要控制任务并发执行数量的需求。</p>
<p>  例如一个爬虫程序，可以通过限制其并发任务数量来降低请求频率，从而避免由于请求过于频繁被封禁问题的发生。</p>
<p>  接下来，本文介绍如何实现一个并发控制器。</p>
<h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> task = <span class="function"><span class="params">timeout</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(timeout);</span><br><span class="line">&#125;, timeout))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taskList = [<span class="number">1000</span>, <span class="number">3000</span>, <span class="number">200</span>, <span class="number">1300</span>, <span class="number">800</span>, <span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startNoConcurrentControl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(NO_CONCURRENT_CONTROL_LOG);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskList.map(<span class="function"><span class="params">item</span> =&gt;</span> task(item)));</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(NO_CONCURRENT_CONTROL_LOG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startNoConcurrentControl();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  上述示例代码利用 Promise.all 方法模拟6个任务并发执行的场景，执行完所有任务的总耗时为 3000 毫秒。</p>
<p>  下面会采用该示例来验证实现方法的正确性。</p>
<h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><p>  由于任务并发执行的数量是有限的，那么就需要一种数据结构来管理不断产生的任务。</p>
<p>  队列的「先进先出」特性可以保证任务并发执行的顺序，在 JavaScript 中可以通过「数组来模拟队列」：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>._queue = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._queue.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._queue.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._queue.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    对于每一个任务，需要管理其执行函数和参数：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(resolve, fn, args) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resolve = resolve;</span><br><span class="line">        <span class="built_in">this</span>.fn = fn;</span><br><span class="line">        <span class="built_in">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    接下来实现核心的 TaskPool 类，该类主要用来控制任务的执行：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(size) &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> Queue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addTask(fn, args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue.push(<span class="keyword">new</span> DelayedTask(resolve, fn, args));</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.size) &#123;</span><br><span class="line">                <span class="built_in">this</span>.size--;</span><br><span class="line">                <span class="keyword">const</span> &#123; <span class="attr">resolve</span>: taskResole, fn, args &#125; = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">                taskResole(<span class="built_in">this</span>.runTask(fn, args));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pullTask() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">        <span class="keyword">const</span> &#123; resolve, fn, args &#125; = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">        resolve(<span class="built_in">this</span>.runTask(fn, args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runTask(fn, args) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Promise</span>.resolve(fn(...args));</span><br><span class="line"></span><br><span class="line">        result.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size--;</span><br><span class="line">            <span class="built_in">this</span>.pullTask();</span><br><span class="line">        &#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size--;</span><br><span class="line">            <span class="built_in">this</span>.pullTask();</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  TaskPool 包含三个关键方法：</p>
<ul>
<li>addTask: 将新的任务放入队列当中，并触发任务池状态检测，如果当前任务池非满载状态，则从队列中取出任务放入任务池中执行。</li>
<li>runTask: 执行当前任务，任务执行完成之后，更新任务池状态，此时触发主动拉取新任务的机制。</li>
<li>pullTask: 如果当前队列不为空，且任务池不满载，则主动取出队列中的任务执行。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0140e0705d364a37bb658a897ecb36c0~tplv-k3u1fbpfcp-watermark.image" alt="流程图"></p>
<p>接下来，将前面示例的并发数控制为2个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cc = <span class="keyword">new</span> ConcurrentControl(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startConcurrentControl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(CONCURRENT_CONTROL_LOG);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskList.map(<span class="function"><span class="params">item</span> =&gt;</span> cc.addTask(task, [item])))</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(CONCURRENT_CONTROL_LOG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startConcurrentControl();</span><br></pre></td></tr></table></figure>

<p>执行流程如下：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f52866e0e6b1401e850f3a0ccabdec78~tplv-k3u1fbpfcp-watermark.image" alt="流程图"></p>
<p>最终执行任务的总耗时为 5000 毫秒。</p>
<h3 id="四、高阶函数优化参数传递"><a href="#四、高阶函数优化参数传递" class="headerlink" title="四、高阶函数优化参数传递"></a>四、高阶函数优化参数传递</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(taskList.map(<span class="function"><span class="params">item</span> =&gt;</span> cc.addTask(task, [item])))</span><br></pre></td></tr></table></figure>

<p>  手动传递每个任务的参数的方式显得非常繁琐，这里可以通过「高阶函数实现参数的自动透传」：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">addTask(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue.push(<span class="keyword">new</span> DelayedTask(resolve, fn, args));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.size) &#123;</span><br><span class="line">                <span class="built_in">this</span>.size--;</span><br><span class="line">                <span class="keyword">const</span> &#123; <span class="attr">resolve</span>: taskResole, <span class="attr">fn</span>: taskFn, <span class="attr">args</span>: taskArgs &#125; = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">                taskResole(<span class="built_in">this</span>.runTask(taskFn, taskArgs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  改造之后的代码显得简洁了很多：</p>
<p>  await Promise.all(taskList.map(cc.addTask(task)))</p>
<p>五、优化出队操作<br>  数组一般都是基于一块「连续内存」来存储，当调用数组的 shift 方法时，首先是删除头部元素（时间复杂度 O(1)），然后需要将未删除元素左移一位（时间复杂度 O(n)），所以 shift 操作的时间复杂度为 O(n)。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5880882cd52483ea5e5752aa4052f9e~tplv-k3u1fbpfcp-watermark.image" alt="执行结果"></p>
<p>  由于 JavaScript 语言的特性，V8 在实现 JSArray 的时候给出了一种空间和时间权衡的解决方案，在不同的场景下，JSArray 会在 FixedArray 和 HashTable 两种模式间切换。</p>
<p>  在 hashTable 模式下，shift 操作省去了左移的时间复杂度，其时间复杂度可以降低为 O(1)，即使如此，shift 仍然是一个耗时的操作。</p>
<p>  在数组元素比较多且需要频繁执行 shift 操作的场景下，可以通过 「reverse + pop」 的方式优化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Benchmark = <span class="built_in">require</span>(<span class="string">&#x27;benchmark&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> suite = <span class="keyword">new</span> Benchmark.Suite;</span><br><span class="line"></span><br><span class="line">suite.add(<span class="string">&#x27;shift&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = generateArray(count);</span><br><span class="line">    <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">        arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">&#x27;reverse + pop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = generateArray(count);</span><br><span class="line">    arr.reverse();</span><br><span class="line">    <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">        arr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">&#x27;cycle&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">&#x27;complete&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Fastest is &#x27;</span> + <span class="built_in">this</span>.filter(<span class="string">&#x27;fastest&#x27;</span>).map(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.run(&#123;</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  通过 benchmark.js 跑出的基准测试数据，可以很容易地看出哪种方式的效率更高：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1954b0030a4f43a2320cb70eab3304~tplv-k3u1fbpfcp-watermark.image" alt="执行效率"></p>
<p>  回顾之前 Queue 类的实现，由于只有一个数组来存储任务，直接使用 reverse + pop 的方式，必然会影响任务执行的次序。</p>
<p>  这里就需要引入双数组的设计，一个数组负责入队操作，一个数组负责出队操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighPerformanceQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.q1 = []; <span class="comment">// 用于 push 数据</span></span><br><span class="line">        <span class="built_in">this</span>.q2 = []; <span class="comment">// 用于 shift 数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.q1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift() &#123;</span><br><span class="line">        <span class="keyword">let</span> q2 = <span class="built_in">this</span>.q2;</span><br><span class="line">        <span class="keyword">if</span> (q2.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> q1 = <span class="built_in">this</span>.q1;</span><br><span class="line">            <span class="keyword">if</span> (q1.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q2 = <span class="built_in">this</span>.q2 = q1.reverse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.q1.length === <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.q2.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过基准测试来验证优化的效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b55e8b8cb2aa4f6f87ff47da7f607b4b~tplv-k3u1fbpfcp-watermark.image" alt="执行结果"></p>
<p>作者：descire<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6912220538286899207">https://juejin.cn/post/6912220538286899207</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div></div><a class="button-hover more" href="/2020/12/02/concurrency/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/11/28/complexity/">时间与空间复杂度</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div><div class="post-content"><div class="main-content content"><h2 id="算法时间与空间复杂度"><a href="#算法时间与空间复杂度" class="headerlink" title="算法时间与空间复杂度"></a>算法时间与空间复杂度</h2><p>算法、数据结构在我们的日常工作中还是很常见的，只要你细心观察，就会发现算可以体现在我们工作中的各个层面.<br>例如:</p>
<ul>
<li>浏览器的历史中的前进后退是不是可以把它看做一个线性的栈结构，history的pop、push对应这个栈的出栈、压栈.</li>
<li>const obj = {}; let obj2 = {}; let a = 1; const a = 1; 用数据结构的思维也可以更好的理解ES6的特性。</li>
</ul>
<p>随着计算机行业发展，不管是前端亦或是后端，算法都是进阶的一个绊脚石，可以说不会算法永远也成不了一个合格<br>的高级工程师，想要进大厂确实要会些算法，但是它并不只是为了面试，它和我们的程序是息息相关的.</p>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>数据结构其实就是是程序存储组织数据的方式，一个数据结构是由程序中的数据元素按照某种逻辑关系组织起来的，是若干个数据元素的组合.</p>
<p>数据结构是程序中处理数据的基本单位，在程序中作为一个整体来使用</p>
<p>例如一个数字 1 或者一个字符 A，它是一种数据结构</p>
<p>例如一个数组 [‘dog’, ‘cat’, ‘wolves’]，它是由字符串组合而成的数组，也是一种数据结构</p>
<p>通俗来说，用一定格式组成的数据都是数据结构，我们比较常见的数据结构有字符串、数组、对象、堆、栈、链表、树、哈希表等等，你可能对着其中的一些数据结构并不了解，不要担心，你并不需要立刻知道它们都是什么，对于前端来说，我们使用 JavaScript 这个令我们又爱又恨的语言，它本身就存在的数据结构很少，那么对于像链表、树等等这些结构都是通过对象来模拟的，这点要先知道.</p>
<p>在许多程序设计当中，数据结构的选择是一个基本的设计考虑因素，系统实现的困难程度和系统构造的质量都严重依赖于是否选择了最优的数据结构，选择最优的数据结构能够有效的提高运行的效率和节约存储空间的使用，但是要知道，没有十全十美的数据结构，每种数据结构都有局限性同样也有优点，要根据需求来选择合适的数据结构.</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>什么是算法，我们都知道 1+2+3=6，为什么等于 6 呢，你可能会说，1 加 2等于 3，两个 3 相加等于 6，这是小学生都会的数学常识，它就是广义上的算法</p>
<p>算法其实就是解决一个问题的完整步骤描述，是指完成一个任务准确而完整的步骤描述</p>
<p>算法的设计很多时候需要取决于数据结构，而算法的实现更依赖于采用的数据结构</p>
<p>提出一个问题的算法是一个从抽象到具体的过程</p>
<p>分析问题，选择数据结构，得出初步的解决方法</p>
<p>将解决方法合理地拆分，整理成许多步骤</p>
<p>为重复的步骤选择合理的循环变量</p>
<p>使用易转化为程序实现的自然语言简练地描述算法</p>
<p>了解了什么是算法之后，我们来看时间和空间复杂度，衡量不同算法之间的优劣我们通常从两个维度来考究</p>
<ul>
<li>时间维度：指执行代码所消耗的时间，即时间复杂度</li>
<li>空间维度：指执行代码所消耗的空间，即空间复杂度</li>
</ul>
<p>接下来就开始逐步剖析时间和空间复杂度了，先说时间复杂度</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在说时间复杂度之前，我们首先要理解一个概念即代码执行次数，也可称之为语句频度或时间频度，用 T(n) 表示</p>
<p>我们用例子来一步一步阐述，首先我们来看函数 fn1</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>我们来看这个函数中的语句会执行多少次</p>
<p>很明显此函数内部只有两个语句，即 console.log(“run”) 和 console.log(“end”)，那么我们说这个函数体内代码执行次数是 2</p>
<p>我们再来看函数 fn2</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>我们先来看函数 fn2 中有几条可执行语句</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">i &lt; n</span><br><span class="line">i++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br></pre></td></tr></table></figure></code></pre>
<p>我们假设 n = 3，然后依次带入进去，看看各个执行语句执行了多少次<br>let i = 0 此条声明语句只在第一次 for 循环声明时执行 1 次<br>i &lt; n 此条语句执行次数根据形参 n 的大小变化，n = 3 时，即 i=0,i=1,i=2,i=3 时会执行，即此条语句执行次数为 n + 1 次<br>i++ 此条语句执行次数也是根据形参 n 的大小变化，n = 3 时，即 i=0,i=1,i=2 时会执行，即 n 次<br>console.log(“run”) 此条语句执行次数还是根据形参 n 的大小变化，n = 3 会执行 3 次，那么此语句在函数内部即会执行 n 次</p>
<p>1 + (n + 1) + n + n = (3n + 2)</p>
<p>那么函数 fn2 内共执行 3n + 2 次</p>
<p>一段代码的总执行次数我们通常会用 T(n) 来表示，那么调用一次上面 fn1/fn2 两函数的总执行次数即</p>
<p>T(n) = 2 // fn1<br>T(n) = 3n + 2 // fn2</p>
<p>上面的 n，指的是为问题的规模，即输入数据的大小或者说数量，你也可以简单的理解为 T 就是函数本身，n 就是参数，也就是说</p>
<p>函数 fn1 任何情况下执行次数都为 2</p>
<p>函数 fn2 的总执行次数会根据 n 的大小变化而产生一个变化</p>
<p>我们思考一下，我们可以使用一段代码的执行总次数来衡量执行速度吗？</p>
<p>答案当然是不行的，当代码行数比较多的时候，我们一条一条的数来计算执行总次数太麻烦了，例如函数中套用函数时、循环中套用循环时，想要精确计算执行次数都是非常麻烦的</p>
<p>所以，在算法中，我们一般用 T(n) 简化后的估算值来表达代码执行的速度，通常我们用大些字母 O 来表示，即大 O 表示法，由于是估算，它表示的是代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度</p>
<p>明确了这个概念以后，我们就可以来算时间复杂度了，还是用上面 fn1/fn2 两函数例</p>
<p>// fn1<br>T(n) = 2</p>
<p>// fn2<br>T(n) = 3n + 2</p>
<p>首先我们来看函数 fn1，它的执行总次数为 2，一个 常数(常数级)，也就是说此函数无论何时它的总执行次数都是 2，是一个不变的值，那么我们使用时间复杂度 O 来表示时直接估算为 1 就可以，即时间复杂度为 O(1)</p>
<p>我们再来看函数 fn2 ，它的执行次数 T(n) 是 3n + 2 即 常数<em>n + 常数，这里我们完全可以看成 常数</em>n 和 +常数 两部分，随着 n 的增大，只有前一个部分会有变化，后面是不变的，所以在表示时间复杂度时就可以忽略后面不变的常数，即 常数<em>n，而 常数</em>n 中过的常数我们也可以直接当做 1，或者说忽略掉这个作为系数的常数，那么最终可以得出函数 fn2 的时间复杂度为 n，即 O(n)</p>
<p>PS：晓得可能有人把数学知识还给老师了，所以解释下</p>
<p>常数： 常数就是指平常的数值，可简单的理解为固定不变的数值</p>
<p>系数： 系数指代数式的单项式中的数字因数，例如 a = 1<em>a则它的系数为1,2b=2</em>b ，则它的系数为 2</p>
<p>我们再来举个例子，如下面这个多项式代指一个函数的 T(n)，求它的时间复杂度</p>
<p>T(n) = 10n^4 + 100n^2 + 1000</p>
<p>其实，对于多项式，我们只需要保留最高次项就行了，也就说，保留 n 的最高次方数就可以了，这个例子中保留的也就是 n 的 4 次方，系数和常数皆可以忽略，最终得到的时间复杂度即为 O(n^4)</p>
<p>结论：</p>
<p>T(n) 为常数时，时间复杂度为 O(1) ，反之时间复杂度为 O(保留T(n)的最高次项并去掉最高次项的系数)</p>
<p>接下来，我们看几个例子来判断下几段代码的时间复杂度</p>
<p>例1：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn01</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你看这是啥&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是一个输出&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>上面这个函数 fn01 中只有一条条的语句，共执行 5 次，毫无变化，时间复杂度即 O(1) ，此为常数级时间复杂度</p>
<p>例2：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn02</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;这是一个输出🎓&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>如上，函数 fn02 同上文中的例子 fn2，一个循环，时间复杂度即为 O(n) ，此为线性级时间复杂度</p>
<p>例3：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn03</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>这个题和上面就不太一样了，我们先单独看内部的循环，内部循环大概会执行 n 次，再来看外部循环又会执行 n 次，最终也就是 n * n = n^2，即函数 fn03 的时间复杂度为 O(n^2) ，此为平方级时间复杂度，如果是三层循环也就是时间复杂度为 O(n^3) 时，即立方级时间复杂度</p>
<p>从这里我们就可以看出来，一段代码有多少层循环，时间复杂度就是 n 的多少次方，所以尽量避免多层循环嵌套</p>
<p>例4：</p>
<p>我们再来看下面这个函数 fn04</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn04</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>此函数中有一个双循环，有一个单循环，即执行次数大概是 n^2 + n，根据我们上面说的保留最高次项，那么函数 fn04 的时间复杂度即为 O(n^2)</p>
<p>例5：</p>
<p>算法中肯定不只是上面那种寻常的循环，再来看下面这一个</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn05</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;外层循环&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;内层循环&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>其实遇到这种，我们直接带入进去试一试即可知其规律</p>
<p>当 i = 0 时，里层循环会执行 n 次</p>
<p>当 i = 1 时，里层循环会执行 n - 1 次</p>
<p>当 i = 2 时，里层循环会执行 n - 2 次</p>
<p>当 i = 3 时，里层循环会执行 n - 3 次</p>
<p>这个时候我们就发现了规律，每当 i 增加 1，里层循环就少执行 1 次，那么就简单了</p>
<p>当 i = n - 2 时，里层循环会执行 2 次</p>
<p>当 i = n - 1 时，里层循环会执行 1 次</p>
<p>最终我们把 n 个里层循环的执行次数相加即可得出最终的一个不精确的总执行次数</p>
<p>T(n) = n + (n - 1) + (n - 2) + … + 3 + 2 + 1</p>
<p>如上，这是一个等差数列，嗯，晓得，会补充</p>
<p>如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，这个数列就叫做等差数列，而这个常数叫做等差数列的公差，公差常用字母 d 表示</p>
<p>例如：1,3,5,7,9……（2n-1) ，等差数列 S(n) 的通项公式为：S(n) = S1 + (n-1) * d，前 n 项和公式如下</p>
<p>S(n) = n<em>S1 + n</em>(n - 1)*d/2</p>
<p>// 或</p>
<p>S(n) = n*(S1 + Sn)/2</p>
<p>如此我们计算结果就成，我们上面的数列中，公差 d 为 -1，带入公式即可，第二个公式简单，用第二个好了，计算结果都是一样的</p>
<p>// n*(S1 + Sn)/2</p>
<p>n*(n + 1)/2 = (n^2 + n)/2 = (1/2)n^2 + (1/2)n</p>
<p>最终我们得到了 (1/2)n^2 + (1/2)n ，按照上文中取最高次项去掉系数，即时间复杂度为 O(n^2)</p>
<p>例6：</p>
<p>再来看一个例子</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn06</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>还是老样子，如果你不晓得怎么看，可以先带入几个参数试一下，看一看规律</p>
<p>我们可以分别使用 n=2, n=4, n=8, n=16，观察其循环中打印次数，当然你也可以直接运行一下代码，过程不过多阐述了，我们直接看结果</p>
<p>n=2 时打印1次 T(n)=1<br>n=4 时打印2次 T(n)=2<br>n=8 时打印3次 T(n)=3<br>n=16 时打印4次 T(n)=4</p>
<p>对于执行次数产生主要影像的就是循环语句中的 i*=2，每次循环 i 都会变成自身的两倍，仔细观察我们就可以得出这样一个规律性结果</p>
<p>n=2 时打印1次 T(n)=1 // 2^1 = 2<br>n=4 时打印2次 T(n)=2 // 2^2 = 4<br>n=8 时打印3次 T(n)=3 // 2^3 = 8<br>n=16 时打印4次 T(n)=4 // 2^4 = 16</p>
<p>根据上面的规律我们不难发现，那么2^执行次数=n，即 2^T(n)=n ，我们求 T(n)，调个就行了，也就是以 2 为底 n 的对数，即 T(n)=log_2 n</p>
<p>PS：又来补数学了</p>
<p>对数： 假如 a^n=b，即 a 的 n 次方等于 b，我们求 n 的值，那么这里为了方便表示就可以写成 log_a b，即以 a 为底 b 的对数，a 是底数，b 是真数，而 n 就是对数</p>
<p>你可能会在纠结为什么只观察循环中的打印次数而不计算其所有的执行次数，原因上面也说过了，这些固有的常数及系数完全可以忽略，好吧，我们再最后推一遍</p>
<p>中间输出为 log_2 n 次，let i = 1 只会执行一次，i&lt;n 会执行 log_2 n + 1 次，i*=2 也会执行 log_2 n 次，加起来就是 log_2 n + log_2 n + 1 + log_2 n，即 3log_2 n + 2，除去系数 3 和常数 2，我们得出了 log_2 n ，在时间复杂度的计算中 log 的底数也是可以省略的，所以最终函数 fn06 的时间复杂度为 O(log n) ，也就是对数级时间复杂度</p>
<p>例7：</p>
<p>最后在给大家来一个例子吧</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn07</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; m)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;你看懂了吗&quot;</span>)</span><br><span class="line">        j = j * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>如上图，此函数有两个参数，对应了里外两个循环，我们先从内部循环看起，眼熟吗？其实内部循环和上题函数 fn06 中的循环是一样的，只是一个用的 for ，一个用的 while，上题中的时间复杂度我们就不再叙述了，那么内层循环时间复杂度为 O(log n)</p>
<p>我们再来看外层循环，也是上面解释过的，单看外层循环时间复杂度是 O(n)</p>
<p>两个循环是嵌套关系，相乘就可以了，所以函数 fn07 的时间复杂度即为 O(n*log n) ，也就是线性对数级时间复杂度</p>
<p>正如此函数输出，你看懂了吗？</p>
<p>常见的时间复杂度量级有</p>
<p>常数级 O(1)<br>对数级 O(log n)<br>线性级 O(n)<br>线性对数级 O(n*log n)<br>平方级 O(n^2)<br>立方级 O(n^3)<br>K次方级 O(n^k)<br>指数级 O(2^n)<br>上面从上到下依次时间复杂度越来越大，执行效率越来越低，大部分常用的在上面的图表中都有展示</p>
<p>所以在程序或是刷题中，我们应该尽量使用低时间复杂度的方法</p>
<p>时间复杂度就到此为止了，我们也列举了常见的时间复杂度，接下来我们来看看空间复杂度</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度其实就是对一个算法或者说一段代码在运行过程中占用存储空间大小表达方式</p>
<p>我们上面讲过了时间复杂度，那么再来说空间复杂度会简单的很多</p>
<p>空间复杂度也就是 S(n) ，它同样会用大O表示法来表示，我们直接上例子</p>
<p>例1：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn001</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;空间复杂度&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>首先，我们知道，空间复杂度和存储空间有关，而存储空间是由什么决定的，肯定是声明的变量啊，我们直接来找函数 fn001 中的变量声明，只有一个 i ，也就是说此函数只有开辟了一块空间供 i 使用，那么空间复杂度 S(n) 即为 O(1) ，你可能会说 i 不是一直在变吗，是的它是在变，但是不管怎么变，它还是一个数字，占用空间大小都一致</p>
<p>空间复杂度和时间复杂度一样，当代码里声明的变量是一个常量，不会根据传入值的变化而变化，那么也它的空间复杂度是 O(1)</p>
<p>例2：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn002</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        arr.push(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>这个例子中我们声明了一个数组，我们知道数组中是可以存各种类型的，在循环中，我们根据 n 的大小向数组 arr 中 push 元素，所以，n 多大，数组就有多少元素，就占用了多少空间，所以空间复杂度S(n) = O(n)</p>
<h3 id="空间复杂度小结"><a href="#空间复杂度小结" class="headerlink" title="空间复杂度小结"></a>空间复杂度小结</h3><p>空间复杂度里，只列出了两个例子，是因为一般情况下，我们用不到其他的，空间复杂度一般只会是 O(1)/O(n)/O(n^2)，其它的很少见，当然也有，我们在知道了时间复杂度再分析空间复杂度也很好分析，就不过多赘述了</p>
<p>关于分析空间复杂度，其实我们直接从声明的变量入手就可以，看函数体内声明的变量根据传入值的变化而变化来分析</p>
<p>另外，这里我们没有列举递归情况，请注意，递归就是函数套函数，像俄罗斯套娃一样的，这中间其实有一个问题，我们知道，递归函数，每层递归里都会开辟一个递归栈，每次递归产生的变量等空间消耗都会存在递归栈中，这也是一个空间，不管你有没有声明变量，只要递归了递归栈它都存在，也就是说只要存在递归的情况，基本上最少的空间复杂度也是 O(n) 了，所以我们尽可能的在能使用迭代的情况下就不使用递归</p>
<h3 id="时间-VS-空间"><a href="#时间-VS-空间" class="headerlink" title="时间 VS 空间"></a>时间 VS 空间</h3><p>开头我们说了，评价一个算法的效率我们主要是从它的时间和空间两个维度看，但是，通常我们在算法中，时间和空间就是鱼和熊掌的关系，这时候可能一道算法题有两种解法，一种时间复杂度低，但空间复杂度稍高，另一种则反之</p>
<p>这个时候怎么办呢？细品就知道了，在开发中，我们一般都是时间优于空间的，你想啊，一个程序，用户不会关心的占用了多少内存，但是他会关心你这个程序他在使用时的执行速度，况且，空间也就是磁盘，现阶段磁盘我们可以花钱扩容，时间上就没这么简单了，所以某些相对的情况下，空间换时间是可以令人接受的</p>
<p>虽说空间换时间可行，但也不能一味的空间换时间，我们还是要尽可能降低两个维度的复杂度，少数对立情况下，可空间换时间</p>
<p>我们在刷算法的时候，不是刷完了就完事了，我们还要去分析我们的题解对应的时间及空间复杂度，可以分析多种题解之间的复杂度，对比找出最优解</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50479555">https://zhuanlan.zhihu.com/p/50479555</a></p>
</div></div><a class="button-hover more" href="/2020/11/28/complexity/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2020/10/07/git-emoji/">git-emoji</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2021-06-01</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;feat: :sparkles: built a Tank, yesterday.&quot;</span><br><span class="line"></span><br><span class="line">git commit -m &quot;feat: :sparkles: built a Rocket, today.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Git提交添加emoji图标"><a href="#Git提交添加emoji图标" class="headerlink" title="Git提交添加emoji图标"></a>Git提交添加emoji图标</h2><p><a target="_blank" rel="noopener" href="https://gitmoji.carloscuesta.me/">https://gitmoji.carloscuesta.me/</a></p>
<img src="/2020/10/07/git-emoji/git_emoji.png" class="" title="This is an image">

<p>在提交内容的前面增加了emoji标签：  **:emoji:**，其中emoji是表情图标的标签，列表见下面的附录表格。</p>
<table>
<thead>
<tr>
<th>emoji</th>
<th>emoji代码</th>
<th>commit 说明</th>
</tr>
</thead>
<tbody><tr>
<td>:art: (调色板)</td>
<td><code>:art:</code></td>
<td>改进代码结构/代码格式</td>
</tr>
<tr>
<td>:zap: (闪电):racehorse: (赛马)</td>
<td><code>:zap:“:racehorse:</code></td>
<td>提升性能</td>
</tr>
<tr>
<td>:fire: (火焰)</td>
<td><code>:fire:</code></td>
<td>移除代码或文件</td>
</tr>
<tr>
<td>:bug: (bug)</td>
<td><code>:bug:</code></td>
<td>修复 bug</td>
</tr>
<tr>
<td>:ambulance: (急救车)</td>
<td><code>:ambulance:</code></td>
<td>重要补丁</td>
</tr>
<tr>
<td>:sparkles: (火花)</td>
<td><code>:sparkles:</code></td>
<td>引入新功能</td>
</tr>
<tr>
<td>:memo: (备忘录)</td>
<td><code>:memo:</code></td>
<td>撰写文档</td>
</tr>
<tr>
<td>:rocket: (火箭)</td>
<td><code>:rocket:</code></td>
<td>部署功能</td>
</tr>
<tr>
<td>:lipstick: (口红)</td>
<td><code>:lipstick:</code></td>
<td>更新 UI 和样式文件</td>
</tr>
<tr>
<td>:tada: (庆祝)</td>
<td><code>:tada:</code></td>
<td>初次提交</td>
</tr>
<tr>
<td>:white_check_mark: (白色复选框)</td>
<td><code>:white_check_mark:</code></td>
<td>增加测试</td>
</tr>
<tr>
<td>:lock: (锁)</td>
<td><code>:lock:</code></td>
<td>修复安全问题</td>
</tr>
<tr>
<td>:apple: (苹果)</td>
<td><code>:apple:</code></td>
<td>修复 macOS 下的问题</td>
</tr>
<tr>
<td>:penguin: (企鹅)</td>
<td><code>:penguin:</code></td>
<td>修复 Linux 下的问题</td>
</tr>
<tr>
<td>:checkered_flag: (旗帜)</td>
<td><code>:checked_flag:</code></td>
<td>修复 Windows 下的问题</td>
</tr>
<tr>
<td>:bookmark: (书签)</td>
<td><code>:bookmark:</code></td>
<td>发行/版本标签</td>
</tr>
<tr>
<td>:rotating_light: (警车灯)</td>
<td><code>:rotating_light:</code></td>
<td>移除 linter 警告</td>
</tr>
<tr>
<td>:construction: (施工)</td>
<td><code>:construction:</code></td>
<td>工作进行中</td>
</tr>
<tr>
<td>:green_heart: (绿心)</td>
<td><code>:green_heart:</code></td>
<td>修复 CI 构建问题</td>
</tr>
<tr>
<td>:arrow_down: (下降箭头)</td>
<td><code>:arrow_down:</code></td>
<td>降级依赖</td>
</tr>
<tr>
<td>:arrow_up: (上升箭头)</td>
<td><code>:arrow_up:</code></td>
<td>升级依赖</td>
</tr>
<tr>
<td>:construction_worker: (工人)</td>
<td><code>:construction_worker:</code></td>
<td>添加 CI 构建系统</td>
</tr>
<tr>
<td>:chart_with_upwards_trend: (上升趋势图)</td>
<td><code>:chart_with_upwards_trend:</code></td>
<td>添加分析或跟踪代码</td>
</tr>
<tr>
<td>:hammer: (锤子)</td>
<td><code>:hammer:</code></td>
<td>重大重构</td>
</tr>
<tr>
<td>:heavy_minus_sign: (减号)</td>
<td><code>:heavy_minus_sign:</code></td>
<td>减少一个依赖</td>
</tr>
<tr>
<td>:whale: (鲸鱼)</td>
<td><code>:whale:</code></td>
<td>Docker 相关工作</td>
</tr>
<tr>
<td>:heavy_plus_sign: (加号)</td>
<td><code>:heavy_plug_sign:</code></td>
<td>增加一个依赖</td>
</tr>
<tr>
<td>:wrench: (扳手)</td>
<td><code>:wrench:</code></td>
<td>修改配置文件</td>
</tr>
<tr>
<td>:globe_with_meridians: (地球)</td>
<td><code>:globe_with_meridians:</code></td>
<td>国际化与本地化</td>
</tr>
<tr>
<td>:pencil2: (铅笔)</td>
<td><code>:pencil2:</code></td>
<td>修复 typo</td>
</tr>
</tbody></table>
</div></div><a class="button-hover more" href="/2020/10/07/git-emoji/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By TheFirstSunday</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>