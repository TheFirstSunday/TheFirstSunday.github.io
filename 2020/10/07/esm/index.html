<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入理解 ES6 模块机制"><meta name="keywords" content="Diary"><meta name="author" content="TheFirstSunday,undefined"><meta name="copyright" content="TheFirstSunday"><title>深入理解 ES6 模块机制【前端-FE】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"V5C7R11NIT","apiKey":"37d9271c02b1e0f2f42bd334f8f0de94","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {},
  valine: {"appId":"EDiQLCtfYJFYtECr3Adwmncl-gzGzoHsz","appKey":"MDXLAYtR8IlmgStY29ElIjge","placeholder":"Just Go Go."},
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">ES6 模块特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">CommonJS 输出值的拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">ES6 输出值的引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ES6 静态编译，CommonJS 运行时加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">CommonJS 模块循环依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">ES6 模块循环依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">动态 import()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">TheFirstSunday</div><div class="author-info-description">FE 前端 JavaScript HTML CSS React Vue Webpack Rollup babel React Native Flutter 小程序 算法</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/TheFirstSunday" target="_blank">GitHub<i class="icon-dot bg-color10"></i></a><a class="links-button button-hover" href="mailto:zhaonan266366@163.com" target="_blank">Email<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2621940203&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">13</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">6</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">1</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">前端-FE</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">深入理解 ES6 模块机制</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-10-07 | 更新于 2021-06-30</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Diary/">Diary</a></div></div></div><div class="main-content"><h1>前言</h1>
今天和同事一起讨论了ES6 模块机制，趁热打铁来复习下ES6 模块机制相关知识。

<p>在 ES6 中，我们知道 import、export 取代了 require、module.exports 用来引入和导出模块，但是如果不了解 ES6 模块特性的话，代码可能就会运行出一些匪夷所思的结果，下面我将通过这篇文章为你揭开 ES6 模块机制特点。</p>
<h1>ES6 模块特性</h1>

<p>说起 ES6 模块特性，那么就先说说 ES6 模块跟 CommonJS 模块的不同之处。</p>
<p>ES6 模块跟 CommonJS 模块的不同，主要有以下两个方面：</p>
<p>ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝<br>ES6 模块编译时执行，而 CommonJS 模块总是在运行时加载<br>这个怎么理解呢？我们一步步来看：</p>
<h1>CommonJS 输出值的拷贝</h1>

<p>CommonJS 模块输出的是值的拷贝(原始值的拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo);</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo);</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">let foo &#x3D; 1;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码说明，b 模块加载以后，它的内部 foo 变化就影响不到输出的 exports.foo 了。这是因为 foo 是一个原始类型的值，会被缓存。所以如果你想要在 CommonJS 中动态获取模块中的值，那么就需要借助于函数延时执行的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo());</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo());</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo());</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">let foo &#x3D; 1;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    foo: () &#x3D;&gt; &#123;</span><br><span class="line">        return foo;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们可以总结一下：</p>
<p>CommonJS 模块重复引入的模块并不会重复执行，再次获取模块直接获得暴露的 module.exports 对象<br>如果你要处处获取到模块内的最新值的话，也可以你每次更新数据的时候每次都要去更新 module.exports 上的值<br>如果你暴露的 module.exports 的属性是个对象，那就不存在这个问题了<br>所以如果你要处处获取到模块内的最新值的话，也可以你每次更新数据的时候每次都要去更新 module.exports 上的值，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.foo);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(b.foo);</span><br><span class="line">    console.log(require(&#39;.&#x2F;b&#39;).foo);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">module.exports.foo &#x3D; 1;   &#x2F;&#x2F; 同 exports.foo &#x3D; 1 </span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    module.exports.foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1>ES6 输出值的引用</h1>  

<p>然而在 ES6 模块中就不再是生成输出对象的拷贝，而是动态关联模块中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">console.log(foo);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">    import(&#39;.&#x2F;b&#39;).then((&#123; foo &#125;) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(foo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    foo &#x3D; 2;</span><br><span class="line">&#125;, 500);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行：babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h1>ES6 静态编译，CommonJS 运行时加载</h1>

<p>关于第二点，ES6 模块编译时执行会导致有以下两个特点：</p>
<p>import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。<br>export 命令会有变量声明提前的效果。<br>import 优先执行:</p>
<p>从第一条来看，在文件中的任何位置引入 import 模块都会被提前到文件顶部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a.js&#39;)</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line">console.log(&#39;b.js 先执行&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果:</span><br><span class="line">&#x2F;&#x2F; b.js 先执行</span><br><span class="line">&#x2F;&#x2F; a.js</span><br></pre></td></tr></table></figure>
<p>从执行结果我们可以很直观地看出，虽然 a 模块中 import 引入晚于 console.log(‘a’)，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。</p>
<p>由于 import 是静态执行，所以 import 具有提升效果即 import 命令在模块中的位置并不影响程序的输出。</p>
<p>export 变量声明提升:</p>
<p>正常的引入模块是没办法看出变量声明提升的特性，需要通过循环依赖加载才能看出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;a.js&#39;);</span><br><span class="line">export const bar &#x3D; 1;</span><br><span class="line"></span><br><span class="line">export const bar2 &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;bar2&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function bar3() &#123;</span><br><span class="line">    console.log(&#39;bar3&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export let foo &#x3D; 1;</span><br><span class="line">import * as a from &#39;.&#x2F;a&#39;;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果:</span><br><span class="line">&#x2F;&#x2F; &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;</span><br><span class="line">&#x2F;&#x2F; a.js</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以很直观地看出，a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明的变量也是优于模块其它内容的执行的，但是具体对变量赋值需要等到执行到相应代码的时候。(当然函数声明和表达式声明不一样，这一点跟 JS 函数性质一样，这里就不过多解释)</p>
<p>好了，讲完了 ES6 模块和 CommonJS 模块的不同点之后，接下来就讲讲相同点：</p>
<p>模块不会重复执行</p>
<p>这个很好理解，无论是 ES6 模块还是 CommonJS 模块，当你重复引入某个相同的模块时，模块只会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">import &#39;.&#x2F;b&#39;;</span><br><span class="line">import &#39;.&#x2F;b&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;只会执行一次&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; 只会执行一次</span><br></pre></td></tr></table></figure>

<p>结合上面说的特性，我们来看一个比较经典的例子，循环依赖，当你理解了上面所讲的特性之后，下次遇到模块循环依赖代码的执行结果就很容易理解了。</p>
<h1>CommonJS 模块循环依赖</h1>

<p>先来看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(&#39;in a, b.done &#x3D;&#39;, b.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;a done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b starting&#39;);</span><br><span class="line">exports.done &#x3D; false;</span><br><span class="line">const a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">console.log(&#39;in b, a.done &#x3D;&#39;, a.done);</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">console.log(&#39;b done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; a starting</span><br><span class="line">&#x2F;&#x2F; b starting</span><br><span class="line">&#x2F;&#x2F; in b, a.done &#x3D; false</span><br><span class="line">&#x2F;&#x2F; b done</span><br><span class="line">&#x2F;&#x2F; in a, b.done &#x3D; true</span><br><span class="line">&#x2F;&#x2F; a done</span><br></pre></td></tr></table></figure>

<p>结合之前讲的特性很好理解，当你从 b 中想引入 a 模块的时候，因为 node 之前已经加载过 a 模块了，所以它不会再去重复执行 a 模块，而是直接去生成当前 a 模块吐出的 module.exports 对象，因为 a 模块引入 b 模块先于给 done 重新赋值，所以当前 a 模块中输出的 module.exports 中 done 的值仍为 false。而当 a 模块中输出 b 模块的 done 值的时候 b 模块已经执行完毕，所以 b 模块中的 done 值为 true。</p>
<p>从上面的执行过程中，我们可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。虽然这种模块加载机制可以避免出现循环依赖时报错的情况，但稍不注意就很可能使得代码并不是像我们想象的那样去执行。因此在写代码时还是需要仔细的规划，以保证循环模块的依赖能正确工作。</p>
<p>所以有什么办法可以出现循环依赖的时候避免自己出现混乱呢？一种解决方式便是将每个模块先写 exports 语法，再写 require语句，利用 CommonJS 的缓存机制，在 require() 其他模块之前先把自身要导出的内容导出，这样就能保证其他模块在使用时可以取到正确的值。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">let b &#x3D; require(&#39;.&#x2F;b&#39;);</span><br><span class="line">console.log(b.done)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">exports.done &#x3D; true;</span><br><span class="line">let a &#x3D; require(&#39;.&#x2F;a&#39;);</span><br><span class="line">console.log(a.done)</span><br></pre></td></tr></table></figure>

<p>这种写法简单明了，缺点是要改变每个模块的写法，而且大部分同学都习惯了在文件开头先写 require 语句。</p>
<h1>ES6 模块循环依赖</h1>

<p>跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a starting&#39;)</span><br><span class="line">import &#123; foo &#125; from &#39;.&#x2F;b&#39;;</span><br><span class="line">console.log(&#39;in b, foo:&#39;, foo);</span><br><span class="line">export const bar &#x3D; 2;</span><br><span class="line">console.log(&#39;a done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b starting&#39;);</span><br><span class="line">import &#123; bar &#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">export const foo &#x3D; &#39;foo&#39;;</span><br><span class="line">console.log(&#39;in a, bar:&#39;, bar);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">console.log(&#39;in a, setTimeout bar:&#39;, bar);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;b done&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果：</span><br><span class="line">&#x2F;&#x2F; b starting</span><br><span class="line">&#x2F;&#x2F; in a, bar: undefined</span><br><span class="line">&#x2F;&#x2F; b done</span><br><span class="line">&#x2F;&#x2F; a starting</span><br><span class="line">&#x2F;&#x2F; in b, foo: foo</span><br><span class="line">&#x2F;&#x2F; a done</span><br><span class="line">&#x2F;&#x2F; in a, setTimeout bar: 2</span><br></pre></td></tr></table></figure>

<h1>动态 import()</h1>

<p>ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(some condition) &#123;</span><br><span class="line">    import a from &#39;.&#x2F;a&#39;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    import b from &#39;.&#x2F;b&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; or </span><br><span class="line">import a from (str + &#39;b&#39;);</span><br></pre></td></tr></table></figure>

<p>因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入 import() 应运而生。</p>
<p>import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。</p>
<p>require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话 require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。<br>而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()<br>我们先来看下它的用法：</p>
<p>动态的 import() 提供一个基于 Promise 的 API<br>动态的import() 可以在脚本的任何地方使用<br>import() 接受字符串文字，你可以根据你的需要构造说明符<br>举个简单的使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">const str &#x3D; &#39;.&#x2F;b&#39;;</span><br><span class="line">const flag &#x3D; true;</span><br><span class="line">if(flag) &#123;</span><br><span class="line">    import(&#39;.&#x2F;b&#39;).then((&#123;foo&#125;) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(foo);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">import(str).then((&#123;foo&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(foo);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">export const foo &#x3D; &#39;foo&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; babel-node a.js</span><br><span class="line">&#x2F;&#x2F; 执行结果</span><br><span class="line">&#x2F;&#x2F; foo</span><br><span class="line">&#x2F;&#x2F; foo</span><br></pre></td></tr></table></figure>

<p>当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。</p>
<p>因为是基于 Promise 的，所以如果你想要同时加载多个模块的话，可以是 Promise.all 进行并行异步加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">    import(&#39;.&#x2F;a.js&#39;),</span><br><span class="line">    import(&#39;.&#x2F;b.js&#39;),</span><br><span class="line">    import(&#39;.&#x2F;c.js&#39;),</span><br><span class="line">]).then(([a, &#123;default: b&#125;, &#123;c&#125;]) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;a.js is loaded dynamically&#39;);</span><br><span class="line">    console.log(&#39;b.js is loaded dynamically&#39;);</span><br><span class="line">    console.log(&#39;c.js is loaded dynamically&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还有 Promise.race 方法，它检查哪个 Promise 被首先 resolved 或 reject。我们可以使用import()来检查哪个CDN速度更快：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const CDNs &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;jQuery.com&#39;,</span><br><span class="line">        url: &#39;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#39;googleapis.com&#39;,</span><br><span class="line">        url: &#39;https:&#x2F;&#x2F;ajax.googleapis.com&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;3.1.1&#x2F;jquery.min.js&#39;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(&#96;------&#96;);</span><br><span class="line">console.log(&#96;jQuery is: $&#123;window.jQuery&#125;&#96;);</span><br><span class="line"></span><br><span class="line">Promise.race([</span><br><span class="line">    import(CDNs[0].url).then(()&#x3D;&gt;console.log(CDNs[0].name, &#39;loaded&#39;)),</span><br><span class="line">    import(CDNs[1].url).then(()&#x3D;&gt;console.log(CDNs[1].name, &#39;loaded&#39;))</span><br><span class="line">]).then(()&#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;jQuery version: $&#123;window.jQuery.fn.jquery&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，如果你觉得这样写还不够优雅，也可以结合 async/await 语法糖来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    const myModule &#x3D; await import(&#39;.&#x2F;myModule.js&#39;);</span><br><span class="line">    const &#123;export1, export2&#125; &#x3D; await import(&#39;.&#x2F;myModule.js&#39;);</span><br><span class="line">    const [module1, module2, module3] &#x3D;</span><br><span class="line">        await Promise.all([</span><br><span class="line">            import(&#39;.&#x2F;module1.js&#39;),</span><br><span class="line">            import(&#39;.&#x2F;module2.js&#39;),</span><br><span class="line">            import(&#39;.&#x2F;module3.js&#39;),</span><br><span class="line">        ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态 import() 为我们提供了以异步方式使用 ES 模块的额外功能。 根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。</p>
<h1>参考文章</h1>

<p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33843378">https://zhuanlan.zhihu.com/p/33843378</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">TheFirstSunday</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://thefirstsunday.github.io/2020/10/07/esm/">https://thefirstsunday.github.io/2020/10/07/esm/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://thefirstsunday.github.io">前端-FE</a>！</span></div></div><div class="post-copyright valine" id="comments-container"><script src="//unpkg.com/valine@1.4.14/dist/Valine.min.js"></script><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2];
}
var flag = false;
var gitFun = function () {
    try {
        var valineObj = window.GLOBAL_CONFIG.valine;
        new Valine({
            el: "#comments-container",
            ...valineObj
        });
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/10/07/git-emoji/"><i class="fas fa-angle-left">&nbsp;</i><span>git-emoji</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2020/10/07/first-blog/"><span>first-blog</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By TheFirstSunday</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>